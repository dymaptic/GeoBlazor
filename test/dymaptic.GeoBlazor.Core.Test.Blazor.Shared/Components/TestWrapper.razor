@using dymaptic.GeoBlazor.Core.Test.Blazor.Shared.Pages
<ErrorBoundary>
    @if (Isolated)
    {
        // don't import the namespace, error bc namespace and type are the same
        <BlazorFrame.BlazorFrame @key="TestClassType.Name" 
                                 @ref="_isolatedFrame"
                                 id="@TestClassType.Name"
                                 Src="@($"/test-frame?class={TestClassType.Name}{(Results is null ? null : $"&results={Uri.EscapeDataString(JsonSerializer.Serialize(Results))}")}")"
                                 SecurityOptions="SecurityOptions"
                                 AllowedOrigins="@AllowedOrigins"
                                 Height="fit-content"
                                 OnValidatedMessage="OnIsolatedTestMessage" />
    }
    else
    {
        <DynamicComponent Type="@TestClassType" @ref="_dynamicComponent" Parameters="@Parameters" />
    }
</ErrorBoundary>

@code {
    [Inject]
    public required NavigationManager NavigationManager { get; set; }

    [Parameter]
    [EditorRequired]
    public required Type TestClassType { get; set; }

    [Parameter]
    [EditorRequired]
    public bool Isolated { get; set; }

    [Parameter]
    [EditorRequired]
    public EventCallback<TestResult> OnTestResults { get; set; }

    [Parameter]
    [EditorRequired]
    public TestResult? Results { get; set; }
    
    [Parameter]
    [EditorRequired]
    public required IJSObjectReference JsTestRunner { get; set; }

    public async Task RunTests(bool onlyFailedTests = false, int skip = 0, CancellationToken cancellationToken = default)
    {
        if (Isolated)
        {
            _expectingResult = true;
            await _isolatedFrame!.SendMessageAsync(new IsolatedTestMessage(TestClassType.Name, nameof(RunTests),
                onlyFailedTests, skip), NavigationManager.BaseUri);

            while (_expectingResult)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    await _isolatedFrame.SendMessageAsync(new IsolatedTestMessage(TestClassType.Name, 
                            nameof(TestFrame.CancelTestRun)), NavigationManager.BaseUri);
                    _expectingResult = false;
                    return;
                }
                
                await Task.Delay(100, cancellationToken);
            }
        }
        else
        {
            await TestRunner!.RunTests(onlyFailedTests, skip, cancellationToken);
        }
    }

    public void Toggle(bool open)
    {
        if (Isolated)
        {
            _isolatedFrame!.SendMessageAsync(new IsolatedTestMessage(TestClassType.Name, nameof(Toggle), open),
                NavigationManager.BaseUri);
        }
        else
        {
            TestRunner!.Toggle(open);
        }
    }

    protected override bool ShouldRender()
    {
        return _allowRender;
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        if (!firstRender)
        {
            _allowRender = false;
        }
    }

    private async Task OnIsolatedTestMessage(BlazorFrame.IframeMessage message)
    {
        switch (message.MessageType)
        {
            case nameof(OnTestResults):
                TestResult result = JsonSerializer.Deserialize<TestResult>(message.Data, JsonSerializerOptions.Web)!;
                await OnTestResults.InvokeAsync(result);
                _expectingResult = false;

                break;
            default:
                throw new NotSupportedException($"Message type {message.MessageType} is not supported.");
        }
    }

    private TestRunnerBase? TestRunner => _dynamicComponent?.Instance as TestRunnerBase;

    private Dictionary<string, object?> Parameters => new() 
    { 
        { nameof(OnTestResults), OnTestResults }, 
        { nameof(Results), Results },
        { nameof(JsTestRunner), JsTestRunner }
    };

    private BlazorFrame.BlazorFrame? _isolatedFrame;
    private DynamicComponent? _dynamicComponent;
    private bool _allowRender = true;
    private bool _expectingResult;
    private List<string> AllowedOrigins =>
    [
        NavigationManager.BaseUri,
        NavigationManager.BaseUri.TrimEnd('/'),
        NavigationManager.ToAbsoluteUri("/test-frame").ToString()
    ];
    private BlazorFrame.MessageSecurityOptions SecurityOptions => new() { AllowedOrigins = AllowedOrigins };
}