@page "/"
@using dymaptic.GeoBlazor.Core.Test.Blazor.Shared.Logging
@using System.Text.RegularExpressions

<h1>Unit Tests</h1>

@if (_results is null)
{
    <p>Loading tests...</p>
}
else
{
    <div class="row">
        <label for="stop-on-fail">
            Stop on first failure
        </label>
        <input type="checkbox" 
               id="stop-on-fail" 
               disabled="@(_running)"
               @bind="_settings.StopOnFail"
               @bind:after="SaveSettings" />
    </div>
    <div class="row">
        <label for="stop-on-fail">
            Retain test results on page reload
        </label>
        <input type="checkbox" 
               id="stop-on-fail"
               disabled="@(_running)"
               @bind="_settings.RetainResultsOnReload"
               @bind:after="SaveSettings" />
    </div>
    if (_running)
    {
        <button style="background-color: hotpink;" @onclick="CancelRun">Stop</button>
    }
    else
    {
        <button @onclick="() => RunNewTests(false, _cts.Token)">Continue Test Run</button>
        <button @onclick="() => RunTests(false, _cts.Token)">Run All Tests</button>
        if (_results.Any(kvp => kvp.Value.Failed.Any()))
        {
            <button @onclick="() => RunTests(true, _cts.Token)">Rerun Failed Tests</button>
        }
    }
    <button @onclick="ToggleAll">@(_showAll ? "Collapse" : "Expand") All</button>
    <div class="result-section">
        @if (_running)
        {
            <span style="color: orange; font-weight: bold">Running... @Remaining tests pending</span>
        }
        else if (_results.Any())
        {
            <span style="color: orange; font-weight: bold">Complete</span>
            <span>, </span>
            <span style="color: green;">Passed: @Passed</span>
            <span>, </span>
            <span style="color: red;">Failed: @Failed</span>
        }
        @foreach (KeyValuePair<string, TestResult> result in _results.OrderBy(kvp => kvp.Key))
        {
            <p style="cursor: pointer;" @onclick="@(() => ScrollAndOpenClass(result.Key))">
                <a>
                    <b>@Extensions.CamelCaseToSpaces(result.Key) - @((MarkupString)$"<span style=\"color: yellow;\">Pending: {result.Value.Pending}</span> | <span style=\"color: green;\">Passed: {result.Value.Passed.Count}</span> | <span style=\"color: red;\">Failed: {result.Value.Failed.Count}</span>")</b>
                </a>
            </p>
        }
    </div>

    foreach (Type type in _testClassTypes)
    {
        bool isIsolated = type.GetCustomAttribute<IsolatedTestAttribute>() != null;
        <TestWrapper TestClassType="type" Isolated="isIsolated" 
                     OnTestResults="OnTestResults" 
                     Results="_results[type.Name]"
                     JsTestRunner="_jsTestRunner"
                     @key="type.Name"
                     @ref="_testComponents[type.Name]" />
    }
}

@code {
    [Inject]
    public required IHostApplicationLifetime HostApplicationLifetime { get; set; }
    
    [Inject]
    public required IJSRuntime JsRuntime { get; set; }
    
    [Inject]
    public required NavigationManager NavigationManager { get; set; }
    
    [Inject]
    public required JsModuleManager JsModuleManager { get; set; }
    
    [Inject]
    public required ITestLogger TestLogger { get; set; }
    
    [CascadingParameter(Name = nameof(RunOnStart))]
    public required bool RunOnStart { get; set; }
    
    /// <summary>
    ///     Only run Pro Tests
    /// </summary>
    [CascadingParameter(Name = nameof(ProOnly))]
    public required bool ProOnly { get; set; }
    
    [CascadingParameter(Name = nameof(TestFilter))]
    public string? TestFilter { get; set; }
    

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_allPassed)
        {
            if (RunOnStart)
            {
                HostApplicationLifetime.StopApplication();
            }
            return;
        }
        
        if (firstRender)
        {
            _jsTestRunner = await JsRuntime.InvokeAsync<IJSObjectReference>("import", 
                "./_content/dymaptic.GeoBlazor.Core.Test.Blazor.Shared/testRunner.js");
            IJSObjectReference? proJs = await JsModuleManager.GetProJsModule(JsRuntime, CancellationToken.None);
            IJSObjectReference coreJs = await JsModuleManager.GetCoreJsModule(JsRuntime, proJs, CancellationToken.None);

            await _jsTestRunner.InvokeVoidAsync("initialize", coreJs);
            
            NavigationManager.RegisterLocationChangingHandler(OnLocationChanging);
            
            await LoadSettings();

            if (!_settings.RetainResultsOnReload)
            {
                return;
            }
            
            FindAllTests();
            
            Dictionary<string, TestResult>? cachedResults = 
                await _jsTestRunner.InvokeAsync<Dictionary<string, TestResult>?>("getTestResults");

            if (cachedResults is { Count: > 0 })
            {
                _results = cachedResults;
            }

            if (_results!.Count > 0)
            {
                string? firstUnpassedClass = _testClassNames
                    .FirstOrDefault(t => !_results.ContainsKey(t) || _results[t].Passed.Count == 0);
                if (firstUnpassedClass is not null && _testClassNames.IndexOf(firstUnpassedClass) > 0)
                {
                    await ScrollAndOpenClass(firstUnpassedClass);
                }
            }
            
            // need an extra render cycle to register the `_testComponents` dictionary
            StateHasChanged();
        }
        else if (RunOnStart && !_running)
        {
            // Auto-run configuration
            _running = true;
            await TestLogger.Log("Starting Test Auto-Run:");
            string? attempts = await JsRuntime.InvokeAsync<string?>("localStorage.getItem", "runAttempts");

            int attemptCount = 0;

            if (attempts is not null && int.TryParse(attempts, out attemptCount))
            {
                if (attemptCount > 5)
                {
                    await JsRuntime.InvokeVoidAsync("localStorage.setItem", "runAttempts", 0);
                    Console.WriteLine("Surpassed 5 reload attempts, exiting.");
                    Environment.ExitCode = 1;
                    HostApplicationLifetime.StopApplication();

                    return;
                }
                
                await TestLogger.Log($"Attempt #{attemptCount}");
            }
            
            await TestLogger.Log("----------");
            
            _allPassed = await RunTests(true, _cts.Token);

            if (!_allPassed)
            {
                await TestLogger.Log("Test Run Failed or Errors Encountered, will reload and make an attempt to continue.");
                attemptCount++;
                await JsRuntime.InvokeVoidAsync("localStorage.setItem", "runAttempts", attemptCount);
                await Task.Delay(1000);
                NavigationManager.NavigateTo("/");
            }
            else
            {
                HostApplicationLifetime.StopApplication();
            }
        }
    }

    private void FindAllTests()
    {
        _results = [];
        Type[] types;

        if (ProOnly)
        {
            var proAssembly = Assembly.Load("dymaptic.GeoBlazor.Pro.Test.Blazor.Shared");
            types = proAssembly.GetTypes()
                .Where(t => t.Name != "ProTestRunnerBase").ToArray();
        }
        else
        {
            var assembly = Assembly.Load("dymaptic.GeoBlazor.Core.Test.Blazor.Shared");
            types = assembly.GetTypes();
            try
            {
                var proAssembly = Assembly.Load("dymaptic.GeoBlazor.Pro.Test.Blazor.Shared");
                types = types.Concat(proAssembly.GetTypes()
                    .Where(t => t.Name != "ProTestRunnerBase")).ToArray();
            }
            catch
            {
                //ignore if not running pro
            }
        }
        
        foreach (Type type in types)
        {
            if (!string.IsNullOrWhiteSpace(TestFilter) && !Regex.IsMatch(type.Name, TestFilter))
            {
                continue;
            }
            
            if (type.IsAssignableTo(typeof(TestRunnerBase)) && (type.Name != nameof(TestRunnerBase)))
            {
                _testClassTypes.Add(type);
                _testComponents[type.Name] = null;

                int testCount = type.GetMethods()
                    .Count(m => m.GetCustomAttribute(typeof(TestMethodAttribute), false) != null);
                _results![type.Name] = new TestResult(type.Name, testCount, [], [], false);
            }
        }

        // sort alphabetically
        _testClassTypes.Sort((t1, t2) => string.Compare(t1.Name, t2.Name, StringComparison.Ordinal));
        _testClassNames = _testClassTypes.Select(t => t.Name).ToList();
    }
    
    private async Task RunNewTests(bool onlyFailedTests = false, CancellationToken token = default)
    {
        string? firstUntestedClass = _testClassNames
            .FirstOrDefault(t => !_results!.ContainsKey(t) || _results[t].Passed.Count == 0);

        if (firstUntestedClass is not null)
        {
            int index = _testClassNames.IndexOf(firstUntestedClass);
            await RunTests(onlyFailedTests, token, index);
        }
        else
        {
            await RunTests(onlyFailedTests, token);
        }
    }

    private async Task<bool> RunTests(bool onlyFailedTests = false, CancellationToken token = default,
        int offset = 0)
    {
        _running = true;
        foreach (var kvp in _testComponents.OrderBy(k => _testClassNames.IndexOf(k.Key)).Skip(offset))
        {
            if (token.IsCancellationRequested)
            {
                break;
            }
            
            if (_results!.TryGetValue(kvp.Key, out TestResult? results))
            {
                if (onlyFailedTests && results.Failed.Count == 0 && results.Passed.Count > 0)
                {
                    break;
                }
            }
            if (kvp.Value != null)
            {
                await kvp.Value!.RunTests(onlyFailedTests, cancellationToken: token);
            }
        }
        
        var resultBuilder = new StringBuilder($@"
# GeoBlazor Unit Test Results
{DateTime.Now}
Passed: {_results!.Values.Select(r => r.Passed.Count).Sum()}
Failed: {_results.Values.Select(r => r.Failed.Count).Sum()}");
        foreach (KeyValuePair<string, TestResult> result in _results)
        {
            resultBuilder.AppendLine($@"
## {result.Key}
Passed: {result.Value.Passed.Count}
Failed: {result.Value.Failed.Count}");
            foreach (KeyValuePair<string, string?> methodResult in result.Value.Passed)
            {
                resultBuilder.AppendLine($@"### {methodResult.Key} - Passed
{methodResult.Value}");
            }

            foreach (KeyValuePair<string, string?> methodResult in result.Value.Failed)
            {
                resultBuilder.AppendLine($@"### {methodResult.Key} - Failed
{methodResult.Value}");
            }
        }
        await TestLogger.Log(resultBuilder.ToString());

        await InvokeAsync(async () =>
        {
            StateHasChanged();
            await Task.Delay(1000, token);
            _running = false;
        });
        return _results.Values.All(r => r.Failed.Count == 0);
    }

    private async Task OnTestResults(TestResult result)
    {
        _results![result.ClassName] = result;
        await SaveResults();
        await InvokeAsync(StateHasChanged);
        if (_settings.StopOnFail && result.Failed.Count > 0)
        {
            await CancelRun();
            await ScrollAndOpenClass(result.ClassName);
        }
    }

    private void ToggleAll()
    {
        _showAll = !_showAll;
        foreach (TestWrapper? component in _testComponents.Values)
        {
            component?.Toggle(_showAll);
        }
    }

    private async Task ScrollAndOpenClass(string className)
    {
        await _jsTestRunner!.InvokeVoidAsync("scrollToTestClass", className);
        TestWrapper? testClass = _testComponents[className];
        testClass?.Toggle(true);
    }

    private async Task CancelRun()
    {
        await _jsTestRunner!.InvokeVoidAsync("setWaitCursor", false);
        await Task.Yield();

        await InvokeAsync(async () =>
        {
            await _cts.CancelAsync();
            _cts = new CancellationTokenSource();
            _running = false;
        });
    }
    
    private async ValueTask OnLocationChanging(LocationChangingContext context)
    {
        await SaveResults();
    }

    private async Task SaveResults()
    {
        await _jsTestRunner!.InvokeVoidAsync("saveTestResults", _results);
    }

    private async Task SaveSettings()
    {
        await _jsTestRunner!.InvokeVoidAsync("saveSettings", _settings);
    }
    
    private async Task LoadSettings()
    {
        TestSettings? settings = await _jsTestRunner!.InvokeAsync<TestSettings?>("loadSettings");
        if (settings is not null)
        {
            _settings = settings;
        }
    }

    private int Remaining => _results?.Sum(r => 
        r.Value.TestCount - (r.Value.Passed.Count + r.Value.Failed.Count)) ?? 0;
    private int Passed => _results?.Sum(r => r.Value.Passed.Count) ?? 0;
    private int Failed => _results?.Sum(r => r.Value.Failed.Count) ?? 0;
    private IJSObjectReference? _jsTestRunner;
    private Dictionary<string, TestResult>? _results;
    private bool _running;
    private readonly List<Type> _testClassTypes = [];
    private List<string> _testClassNames = [];
    private readonly Dictionary<string, TestWrapper?> _testComponents = new();
    private bool _showAll;
    private CancellationTokenSource _cts = new();
    private TestSettings _settings = new(false, true);
    private bool _allPassed;

    public record TestSettings(bool StopOnFail, bool RetainResultsOnReload)
    {
        public bool StopOnFail { get; set; } = StopOnFail;
        public bool RetainResultsOnReload { get; set; } = RetainResultsOnReload;
    }

}