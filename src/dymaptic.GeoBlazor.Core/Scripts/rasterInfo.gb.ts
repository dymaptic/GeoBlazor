// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import RasterInfo from '@arcgis/core/layers/support/RasterInfo';
import { arcGisObjectRefs, jsObjectRefs, hasValue, sanitize } from './arcGisJsInterop';
import { buildDotNetRasterInfo } from './rasterInfo';

export async function buildJsRasterInfoGenerated(dotNetObject: any): Promise<any> {
    let properties: any = {};
    if (hasValue(dotNetObject.attributeTable)) {
        let { buildJsFeatureSet } = await import('./featureSet');
        properties.attributeTable = buildJsFeatureSet(dotNetObject.attributeTable) as any;
    }
    if (hasValue(dotNetObject.extent)) {
        let { buildJsExtent } = await import('./extent');
        properties.extent = buildJsExtent(dotNetObject.extent) as any;
    }
    if (hasValue(dotNetObject.sensorInfo)) {
        let { buildJsRasterSensorInfo } = await import('./rasterSensorInfo');
        properties.sensorInfo = await buildJsRasterSensorInfo(dotNetObject.sensorInfo) as any;
    }

    if (hasValue(dotNetObject.bandCount)) {
        properties.bandCount = dotNetObject.bandCount;
    }
    if (hasValue(dotNetObject.bandInfos) && dotNetObject.bandInfos.length > 0) {
        properties.bandInfos = dotNetObject.bandInfos;
    }
    if (hasValue(dotNetObject.colormap) && dotNetObject.colormap.length > 0) {
        properties.colormap = dotNetObject.colormap;
    }
    if (hasValue(dotNetObject.dataType)) {
        properties.dataType = dotNetObject.dataType;
    }
    if (hasValue(dotNetObject.hasMultidimensionalTranspose)) {
        properties.hasMultidimensionalTranspose = dotNetObject.hasMultidimensionalTranspose;
    }
    if (hasValue(dotNetObject.height)) {
        properties.height = dotNetObject.height;
    }
    if (hasValue(dotNetObject.histograms) && dotNetObject.histograms.length > 0) {
        properties.histograms = dotNetObject.histograms;
    }
    if (hasValue(dotNetObject.keyProperties)) {
        properties.keyProperties = dotNetObject.keyProperties;
    }
    if (hasValue(dotNetObject.multidimensionalInfo)) {
        properties.multidimensionalInfo = dotNetObject.multidimensionalInfo;
    }
    if (hasValue(dotNetObject.noDataValue)) {
        properties.noDataValue = dotNetObject.noDataValue;
    }
    if (hasValue(dotNetObject.pixelSize)) {
        properties.pixelSize = dotNetObject.pixelSize;
    }
    if (hasValue(dotNetObject.pixelType)) {
        properties.pixelType = dotNetObject.pixelType;
    }
    if (hasValue(dotNetObject.spatialReference)) {
        properties.spatialReference = sanitize(dotNetObject.spatialReference);
    }
    if (hasValue(dotNetObject.statistics) && dotNetObject.statistics.length > 0) {
        properties.statistics = dotNetObject.statistics;
    }
    if (hasValue(dotNetObject.width)) {
        properties.width = dotNetObject.width;
    }
    let jsRasterInfo = new RasterInfo(properties);
    
    let jsObjectRef = DotNet.createJSObjectReference(jsRasterInfo);
    jsObjectRefs[dotNetObject.id] = jsObjectRef;
    arcGisObjectRefs[dotNetObject.id] = jsRasterInfo;
    
    return jsRasterInfo;
}


export async function buildDotNetRasterInfoGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetRasterInfo: any = {};
    
    if (hasValue(jsObject.extent)) {
        let { buildDotNetExtent } = await import('./extent');
        dotNetRasterInfo.extent = buildDotNetExtent(jsObject.extent);
    }
    
    if (hasValue(jsObject.sensorInfo)) {
        let { buildDotNetRasterSensorInfo } = await import('./rasterSensorInfo');
        dotNetRasterInfo.sensorInfo = await buildDotNetRasterSensorInfo(jsObject.sensorInfo);
    }
    
    if (hasValue(jsObject.bandCount)) {
        dotNetRasterInfo.bandCount = jsObject.bandCount;
    }
    
    if (hasValue(jsObject.bandInfos)) {
        dotNetRasterInfo.bandInfos = jsObject.bandInfos;
    }
    
    if (hasValue(jsObject.colormap)) {
        dotNetRasterInfo.colormap = jsObject.colormap;
    }
    
    if (hasValue(jsObject.dataType)) {
        dotNetRasterInfo.dataType = jsObject.dataType;
    }
    
    if (hasValue(jsObject.hasMultidimensionalTranspose)) {
        dotNetRasterInfo.hasMultidimensionalTranspose = jsObject.hasMultidimensionalTranspose;
    }
    
    if (hasValue(jsObject.height)) {
        dotNetRasterInfo.height = jsObject.height;
    }
    
    if (hasValue(jsObject.histograms)) {
        dotNetRasterInfo.histograms = jsObject.histograms;
    }
    
    if (hasValue(jsObject.keyProperties)) {
        dotNetRasterInfo.keyProperties = jsObject.keyProperties;
    }
    
    if (hasValue(jsObject.multidimensionalInfo)) {
        dotNetRasterInfo.multidimensionalInfo = jsObject.multidimensionalInfo;
    }
    
    if (hasValue(jsObject.noDataValue)) {
        dotNetRasterInfo.noDataValue = jsObject.noDataValue;
    }
    
    if (hasValue(jsObject.pixelSize)) {
        dotNetRasterInfo.pixelSize = jsObject.pixelSize;
    }
    
    if (hasValue(jsObject.pixelType)) {
        dotNetRasterInfo.pixelType = jsObject.pixelType;
    }
    
    if (hasValue(jsObject.spatialReference)) {
        dotNetRasterInfo.spatialReference = jsObject.spatialReference;
    }
    
    if (hasValue(jsObject.statistics)) {
        dotNetRasterInfo.statistics = jsObject.statistics;
    }
    
    if (hasValue(jsObject.width)) {
        dotNetRasterInfo.width = jsObject.width;
    }
    

    return dotNetRasterInfo;
}

