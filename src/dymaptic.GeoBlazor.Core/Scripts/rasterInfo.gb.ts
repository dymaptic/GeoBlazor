// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import RasterInfo from '@arcgis/core/layers/support/RasterInfo';
import { arcGisObjectRefs, jsObjectRefs, hasValue, removeCircularReferences } from './arcGisJsInterop';
import { buildDotNetRasterInfo } from './rasterInfo';

export async function buildJsRasterInfoGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(dotNetObject)) {
        return null;
    }

    let properties: any = {};
    if (hasValue(dotNetObject.attributeTable)) {
        let { buildJsFeatureSet } = await import('./featureSet');
        properties.attributeTable = buildJsFeatureSet(dotNetObject.attributeTable) as any;
    }
    if (hasValue(dotNetObject.extent)) {
        let { buildJsExtent } = await import('./extent');
        properties.extent = buildJsExtent(dotNetObject.extent) as any;
    }
    if (hasValue(dotNetObject.multidimensionalInfo)) {
        let { buildJsRasterMultidimensionalInfo } = await import('./rasterMultidimensionalInfo');
        properties.multidimensionalInfo = await buildJsRasterMultidimensionalInfo(dotNetObject.multidimensionalInfo, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.spatialReference)) {
        let { buildJsSpatialReference } = await import('./spatialReference');
        properties.spatialReference = buildJsSpatialReference(dotNetObject.spatialReference) as any;
    }

    if (hasValue(dotNetObject.bandCount)) {
        properties.bandCount = dotNetObject.bandCount;
    }
    if (hasValue(dotNetObject.colormap) && dotNetObject.colormap.length > 0) {
        properties.colormap = dotNetObject.colormap;
    }
    if (hasValue(dotNetObject.hasMultidimensionalTranspose)) {
        properties.hasMultidimensionalTranspose = dotNetObject.hasMultidimensionalTranspose;
    }
    if (hasValue(dotNetObject.height)) {
        properties.height = dotNetObject.height;
    }
    if (hasValue(dotNetObject.histograms) && dotNetObject.histograms.length > 0) {
        properties.histograms = dotNetObject.histograms;
    }
    if (hasValue(dotNetObject.keyProperties)) {
        properties.keyProperties = dotNetObject.keyProperties;
    }
    if (hasValue(dotNetObject.noDataValue)) {
        properties.noDataValue = dotNetObject.noDataValue;
    }
    if (hasValue(dotNetObject.pixelSize)) {
        properties.pixelSize = dotNetObject.pixelSize;
    }
    if (hasValue(dotNetObject.pixelType)) {
        properties.pixelType = dotNetObject.pixelType;
    }
    if (hasValue(dotNetObject.statistics) && dotNetObject.statistics.length > 0) {
        properties.statistics = dotNetObject.statistics;
    }
    if (hasValue(dotNetObject.width)) {
        properties.width = dotNetObject.width;
    }
    let jsRasterInfo = new RasterInfo(properties);
    
    jsObjectRefs[dotNetObject.id] = jsRasterInfo;
    arcGisObjectRefs[dotNetObject.id] = jsRasterInfo;
    
    return jsRasterInfo;
}


export async function buildDotNetRasterInfoGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetRasterInfo: any = {};
    
    if (hasValue(jsObject.extent)) {
        let { buildDotNetExtent } = await import('./extent');
        dotNetRasterInfo.extent = buildDotNetExtent(jsObject.extent);
    }
    
    if (hasValue(jsObject.multidimensionalInfo)) {
        let { buildDotNetRasterMultidimensionalInfo } = await import('./rasterMultidimensionalInfo');
        dotNetRasterInfo.multidimensionalInfo = await buildDotNetRasterMultidimensionalInfo(jsObject.multidimensionalInfo);
    }
    
    if (hasValue(jsObject.sensorInfo)) {
        let { buildDotNetRasterSensorInfo } = await import('./rasterSensorInfo');
        dotNetRasterInfo.sensorInfo = await buildDotNetRasterSensorInfo(jsObject.sensorInfo);
    }
    
    if (hasValue(jsObject.spatialReference)) {
        let { buildDotNetSpatialReference } = await import('./spatialReference');
        dotNetRasterInfo.spatialReference = buildDotNetSpatialReference(jsObject.spatialReference);
    }
    
    if (hasValue(jsObject.bandCount)) {
        dotNetRasterInfo.bandCount = jsObject.bandCount;
    }
    
    if (hasValue(jsObject.bandInfos)) {
        dotNetRasterInfo.bandInfos = removeCircularReferences(jsObject.bandInfos);
    }
    
    if (hasValue(jsObject.colormap)) {
        dotNetRasterInfo.colormap = removeCircularReferences(jsObject.colormap);
    }
    
    if (hasValue(jsObject.dataType)) {
        dotNetRasterInfo.dataType = removeCircularReferences(jsObject.dataType);
    }
    
    if (hasValue(jsObject.hasMultidimensionalTranspose)) {
        dotNetRasterInfo.hasMultidimensionalTranspose = jsObject.hasMultidimensionalTranspose;
    }
    
    if (hasValue(jsObject.height)) {
        dotNetRasterInfo.height = jsObject.height;
    }
    
    if (hasValue(jsObject.histograms)) {
        dotNetRasterInfo.histograms = removeCircularReferences(jsObject.histograms);
    }
    
    if (hasValue(jsObject.keyProperties)) {
        dotNetRasterInfo.keyProperties = removeCircularReferences(jsObject.keyProperties);
    }
    
    if (hasValue(jsObject.noDataValue)) {
        dotNetRasterInfo.noDataValue = removeCircularReferences(jsObject.noDataValue);
    }
    
    if (hasValue(jsObject.pixelSize)) {
        dotNetRasterInfo.pixelSize = removeCircularReferences(jsObject.pixelSize);
    }
    
    if (hasValue(jsObject.pixelType)) {
        dotNetRasterInfo.pixelType = removeCircularReferences(jsObject.pixelType);
    }
    
    if (hasValue(jsObject.statistics)) {
        dotNetRasterInfo.statistics = removeCircularReferences(jsObject.statistics);
    }
    
    if (hasValue(jsObject.width)) {
        dotNetRasterInfo.width = jsObject.width;
    }
    

    return dotNetRasterInfo;
}

