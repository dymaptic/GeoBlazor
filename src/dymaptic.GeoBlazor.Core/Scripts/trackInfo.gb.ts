// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import TrackInfo from '@arcgis/core/layers/support/TrackInfo';
import { arcGisObjectRefs, jsObjectRefs, hasValue, lookupGeoBlazorId, removeCircularReferences } from './arcGisJsInterop';
import { buildDotNetTrackInfo } from './trackInfo';

export async function buildJsTrackInfoGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(dotNetObject)) {
        return null;
    }

    let properties: any = {};
    if (hasValue(dotNetObject.fields) && dotNetObject.fields.length > 0) {
        let { buildJsAggregateField } = await import('./aggregateField');
        properties.fields = await Promise.all(dotNetObject.fields.map(async i => await buildJsAggregateField(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.latestObservations)) {
        let { buildJsTrackPartInfo } = await import('./trackPartInfo');
        properties.latestObservations = await buildJsTrackPartInfo(dotNetObject.latestObservations, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.maxDisplayDuration)) {
        let { buildJsTimeInterval } = await import('./timeInterval');
        properties.maxDisplayDuration = await buildJsTimeInterval(dotNetObject.maxDisplayDuration) as any;
    }
    if (hasValue(dotNetObject.popupTemplate)) {
        let { buildJsPopupTemplate } = await import('./popupTemplate');
        properties.popupTemplate = buildJsPopupTemplate(dotNetObject.popupTemplate, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.previousObservations)) {
        let { buildJsTrackPartInfo } = await import('./trackPartInfo');
        properties.previousObservations = await buildJsTrackPartInfo(dotNetObject.previousObservations, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.trackLines)) {
        let { buildJsTrackPartInfo } = await import('./trackPartInfo');
        properties.trackLines = await buildJsTrackPartInfo(dotNetObject.trackLines, layerId, viewId) as any;
    }

    if (hasValue(dotNetObject.enabled)) {
        properties.enabled = dotNetObject.enabled;
    }
    if (hasValue(dotNetObject.maxDisplayObservationsPerTrack)) {
        properties.maxDisplayObservationsPerTrack = dotNetObject.maxDisplayObservationsPerTrack;
    }
    if (hasValue(dotNetObject.popupEnabled)) {
        properties.popupEnabled = dotNetObject.popupEnabled;
    }
    if (hasValue(dotNetObject.timeField)) {
        properties.timeField = dotNetObject.timeField;
    }
    let jsTrackInfo = new TrackInfo(properties);
    
    jsObjectRefs[dotNetObject.id] = jsTrackInfo;
    arcGisObjectRefs[dotNetObject.id] = jsTrackInfo;
    
    return jsTrackInfo;
}


export async function buildDotNetTrackInfoGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetTrackInfo: any = {};
    
    if (hasValue(jsObject.fields)) {
        let { buildDotNetAggregateField } = await import('./aggregateField');
        dotNetTrackInfo.fields = await Promise.all(jsObject.fields.map(async i => await buildDotNetAggregateField(i)));
    }
    
    if (hasValue(jsObject.latestObservations)) {
        let { buildDotNetTrackPartInfo } = await import('./trackPartInfo');
        dotNetTrackInfo.latestObservations = await buildDotNetTrackPartInfo(jsObject.latestObservations);
    }
    
    if (hasValue(jsObject.maxDisplayDuration)) {
        let { buildDotNetTimeInterval } = await import('./timeInterval');
        dotNetTrackInfo.maxDisplayDuration = await buildDotNetTimeInterval(jsObject.maxDisplayDuration);
    }
    
    if (hasValue(jsObject.popupTemplate)) {
        let { buildDotNetPopupTemplate } = await import('./popupTemplate');
        dotNetTrackInfo.popupTemplate = await buildDotNetPopupTemplate(jsObject.popupTemplate);
    }
    
    if (hasValue(jsObject.previousObservations)) {
        let { buildDotNetTrackPartInfo } = await import('./trackPartInfo');
        dotNetTrackInfo.previousObservations = await buildDotNetTrackPartInfo(jsObject.previousObservations);
    }
    
    if (hasValue(jsObject.trackLines)) {
        let { buildDotNetTrackPartInfo } = await import('./trackPartInfo');
        dotNetTrackInfo.trackLines = await buildDotNetTrackPartInfo(jsObject.trackLines);
    }
    
    if (hasValue(jsObject.enabled)) {
        dotNetTrackInfo.enabled = jsObject.enabled;
    }
    
    if (hasValue(jsObject.maxDisplayObservationsPerTrack)) {
        dotNetTrackInfo.maxDisplayObservationsPerTrack = jsObject.maxDisplayObservationsPerTrack;
    }
    
    if (hasValue(jsObject.popupEnabled)) {
        dotNetTrackInfo.popupEnabled = jsObject.popupEnabled;
    }
    
    if (hasValue(jsObject.timeField)) {
        dotNetTrackInfo.timeField = removeCircularReferences(jsObject.timeField);
    }
    

    let geoBlazorId = lookupGeoBlazorId(jsObject);
    if (hasValue(geoBlazorId)) {
        dotNetTrackInfo.id = geoBlazorId;
    }

    return dotNetTrackInfo;
}

