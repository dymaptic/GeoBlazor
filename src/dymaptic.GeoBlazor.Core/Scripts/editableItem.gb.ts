import { buildDotNetEditableItem } from './editableItem';
// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file
import EditableItem = __esri.EditableItem;
import {arcGisObjectRefs, hasValue, jsObjectRefs} from './arcGisJsInterop';
export async function buildJsEditableItemGenerated(dotNetObject: any): Promise<any> {
    let jsEditableItem: any = {}
    if (hasValue(dotNetObject.layer)) {
        let { buildJsLayer } = await import('./layer');
        jsEditableItem.layer = await buildJsLayer(dotNetObject.layer, layerId, viewId) as any;
    }

    if (hasValue(dotNetObject.attachmentsOnCreateEnabled)) {
        jsEditableItem.attachmentsOnCreateEnabled = dotNetObject.attachmentsOnCreateEnabled;
    }
    if (hasValue(dotNetObject.attachmentsOnUpdateEnabled)) {
        jsEditableItem.attachmentsOnUpdateEnabled = dotNetObject.attachmentsOnUpdateEnabled;
    }
    if (hasValue(dotNetObject.attributeUpdatesEnabled)) {
        jsEditableItem.attributeUpdatesEnabled = dotNetObject.attributeUpdatesEnabled;
    }
    if (hasValue(dotNetObject.geometryUpdatesEnabled)) {
        jsEditableItem.geometryUpdatesEnabled = dotNetObject.geometryUpdatesEnabled;
    }
    if (hasValue(dotNetObject.hasAttachments)) {
        jsEditableItem.hasAttachments = dotNetObject.hasAttachments;
    }
    if (hasValue(dotNetObject.hasInvalidFormTemplate)) {
        jsEditableItem.hasInvalidFormTemplate = dotNetObject.hasInvalidFormTemplate;
    }
    if (hasValue(dotNetObject.supports)) {
        jsEditableItem.supports = dotNetObject.supports;
    }
    
    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(jsEditableItem);
    jsObjectRefs[dotNetObject.id] = jsObjectRef;
    arcGisObjectRefs[dotNetObject.id] = jsEditableItem;
    
    let dnInstantiatedObject = await buildDotNetEditableItem(jsEditableItem);
    
    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for EditableItem', e);
    }
    
    return jsEditableItem;
}
export async function buildDotNetEditableItemGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetEditableItem: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };
        if (hasValue(jsObject.attachmentsOnCreateEnabled)) {
            dotNetEditableItem.attachmentsOnCreateEnabled = jsObject.attachmentsOnCreateEnabled;
        }
        if (hasValue(jsObject.attachmentsOnUpdateEnabled)) {
            dotNetEditableItem.attachmentsOnUpdateEnabled = jsObject.attachmentsOnUpdateEnabled;
        }
        if (hasValue(jsObject.attributeUpdatesEnabled)) {
            dotNetEditableItem.attributeUpdatesEnabled = jsObject.attributeUpdatesEnabled;
        }
        if (hasValue(jsObject.geometryUpdatesEnabled)) {
            dotNetEditableItem.geometryUpdatesEnabled = jsObject.geometryUpdatesEnabled;
        }
        if (hasValue(jsObject.hasAttachments)) {
            dotNetEditableItem.hasAttachments = jsObject.hasAttachments;
        }
        if (hasValue(jsObject.hasInvalidFormTemplate)) {
            dotNetEditableItem.hasInvalidFormTemplate = jsObject.hasInvalidFormTemplate;
        }
        if (hasValue(jsObject.supports)) {
            dotNetEditableItem.supports = jsObject.supports;
        }

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetEditableItem.id = k;
                break;
            }
        }
    }

    return dotNetEditableItem;
}

