// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import RasterStretchRenderer from '@arcgis/core/renderers/RasterStretchRenderer';
import { arcGisObjectRefs, jsObjectRefs, hasValue, lookupGeoBlazorId, removeCircularReferences } from './arcGisJsInterop';
import { buildDotNetRasterStretchRenderer } from './rasterStretchRenderer';

export async function buildJsRasterStretchRendererGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(dotNetObject)) {
        return null;
    }

    let properties: any = {};
    if (hasValue(dotNetObject.colorRamp)) {
        let { buildJsColorRamp } = await import('./colorRamp');
        properties.colorRamp = buildJsColorRamp(dotNetObject.colorRamp) as any;
    }

    if (hasValue(dotNetObject.computeGamma)) {
        properties.computeGamma = dotNetObject.computeGamma;
    }
    if (hasValue(dotNetObject.customStatistics) && dotNetObject.customStatistics.length > 0) {
        properties.customStatistics = dotNetObject.customStatistics;
    }
    if (hasValue(dotNetObject.dynamicRangeAdjustment)) {
        properties.dynamicRangeAdjustment = dotNetObject.dynamicRangeAdjustment;
    }
    if (hasValue(dotNetObject.gamma) && dotNetObject.gamma.length > 0) {
        properties.gamma = dotNetObject.gamma;
    }
    if (hasValue(dotNetObject.maxPercent)) {
        properties.maxPercent = dotNetObject.maxPercent;
    }
    if (hasValue(dotNetObject.minPercent)) {
        properties.minPercent = dotNetObject.minPercent;
    }
    if (hasValue(dotNetObject.numberOfStandardDeviations)) {
        properties.numberOfStandardDeviations = dotNetObject.numberOfStandardDeviations;
    }
    if (hasValue(dotNetObject.outputMax)) {
        properties.outputMax = dotNetObject.outputMax;
    }
    if (hasValue(dotNetObject.outputMin)) {
        properties.outputMin = dotNetObject.outputMin;
    }
    if (hasValue(dotNetObject.sigmoidStrengthLevel)) {
        properties.sigmoidStrengthLevel = dotNetObject.sigmoidStrengthLevel;
    }
    if (hasValue(dotNetObject.statistics) && dotNetObject.statistics.length > 0) {
        properties.statistics = dotNetObject.statistics;
    }
    if (hasValue(dotNetObject.stretchType)) {
        properties.stretchType = dotNetObject.stretchType;
    }
    if (hasValue(dotNetObject.useGamma)) {
        properties.useGamma = dotNetObject.useGamma;
    }
    let jsRasterStretchRenderer = new RasterStretchRenderer(properties);
    
    jsObjectRefs[dotNetObject.id] = jsRasterStretchRenderer;
    arcGisObjectRefs[dotNetObject.id] = jsRasterStretchRenderer;
    
    return jsRasterStretchRenderer;
}


export async function buildDotNetRasterStretchRendererGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetRasterStretchRenderer: any = {};
    
    if (hasValue(jsObject.colorRamp)) {
        let { buildDotNetColorRamp } = await import('./colorRamp');
        dotNetRasterStretchRenderer.colorRamp = buildDotNetColorRamp(jsObject.colorRamp);
    }
    
    if (hasValue(jsObject.computeGamma)) {
        dotNetRasterStretchRenderer.computeGamma = jsObject.computeGamma;
    }
    
    if (hasValue(jsObject.customStatistics)) {
        dotNetRasterStretchRenderer.customStatistics = removeCircularReferences(jsObject.customStatistics);
    }
    
    if (hasValue(jsObject.dynamicRangeAdjustment)) {
        dotNetRasterStretchRenderer.dynamicRangeAdjustment = jsObject.dynamicRangeAdjustment;
    }
    
    if (hasValue(jsObject.gamma)) {
        dotNetRasterStretchRenderer.gamma = jsObject.gamma;
    }
    
    if (hasValue(jsObject.maxPercent)) {
        dotNetRasterStretchRenderer.maxPercent = jsObject.maxPercent;
    }
    
    if (hasValue(jsObject.minPercent)) {
        dotNetRasterStretchRenderer.minPercent = jsObject.minPercent;
    }
    
    if (hasValue(jsObject.numberOfStandardDeviations)) {
        dotNetRasterStretchRenderer.numberOfStandardDeviations = jsObject.numberOfStandardDeviations;
    }
    
    if (hasValue(jsObject.outputMax)) {
        dotNetRasterStretchRenderer.outputMax = jsObject.outputMax;
    }
    
    if (hasValue(jsObject.outputMin)) {
        dotNetRasterStretchRenderer.outputMin = jsObject.outputMin;
    }
    
    if (hasValue(jsObject.sigmoidStrengthLevel)) {
        dotNetRasterStretchRenderer.sigmoidStrengthLevel = jsObject.sigmoidStrengthLevel;
    }
    
    if (hasValue(jsObject.stretchType)) {
        dotNetRasterStretchRenderer.stretchType = removeCircularReferences(jsObject.stretchType);
    }
    
    if (hasValue(jsObject.type)) {
        dotNetRasterStretchRenderer.type = removeCircularReferences(jsObject.type);
    }
    
    if (hasValue(jsObject.useGamma)) {
        dotNetRasterStretchRenderer.useGamma = jsObject.useGamma;
    }
    

    let geoBlazorId = lookupGeoBlazorId(jsObject);
    if (hasValue(geoBlazorId)) {
        dotNetRasterStretchRenderer.id = geoBlazorId;
    }

    return dotNetRasterStretchRenderer;
}

