// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file



import FeatureLayer from '@arcgis/core/layers/FeatureLayer';
import {IPropertyWrapper} from './definitions';
import {
    arcGisObjectRefs,
    buildJsFeatureLayerBaseElevationInfo,
    buildJsLabel,
    buildJsLayerFloorInfo,
    buildJsOrderedLayerOrderBy,
    buildJsTimeExtent, buildJsTimeInfo, buildJsTimeInterval,
    createGeoBlazorObject,
    hasValue,
    jsObjectRefs
} from './arcGisJsInterop';

export default class FeatureLayerGenerated implements IPropertyWrapper {
    public layer: FeatureLayer;
    private readonly geoBlazorId: string = '';

    constructor(layer: FeatureLayer) {
        this.layer = layer;
        // set all properties from layer
        for (let prop in layer) {
            if (layer.hasOwnProperty(prop)) {
                this[prop] = layer[prop];
            }
        }
    }
    
    // region methods
   
    unwrap() {
        return this.layer;
    }
    
    async load(options: AbortSignal): Promise<void> {
        await this.layer.load(options);
    }

    async addAttachment(feature: any,
        attachment: any): Promise<any> {
        let jsFeature = await buildJsGraphic(feature) as any;
        let result = await this.layer.addAttachment(jsFeature,
            attachment);
        return await createGeoBlazorObject(result);
    }

    async applyEdits(edits: any,
        options: any): Promise<any> {
        let result = await this.layer.applyEdits(edits,
            options);
        return await createGeoBlazorObject(result);
    }

    async createLayerView(view: any,
        options: any): Promise<any> {
        let result = await this.layer.createLayerView(view,
            options);
        return await createGeoBlazorObject(result);
    }

    async deleteAttachments(feature: any,
        attachmentIds: any): Promise<any> {
        let jsFeature = await buildJsGraphic(feature) as any;
        let result = await this.layer.deleteAttachments(jsFeature,
            attachmentIds);
        return await createGeoBlazorObject(result);
    }

    async fetchAttributionData(): Promise<any> {
        return await this.layer.fetchAttributionData();
    }

    async queryAttachments(attachmentQuery: any,
        options: any): Promise<any> {
        let result = await this.layer.queryAttachments(attachmentQuery,
            options);
        return await createGeoBlazorObject(result);
    }

    async save(options: any): Promise<any> {
        let result = await this.layer.save(options);
        return await createGeoBlazorObject(result);
    }

    async saveAs(portalItem: any,
        options: any): Promise<any> {
        let { buildJsPortalItem } = await import('./jsBuilder');
        let jsPortalItem = await buildJsPortalItem(portalItem) as any;
        let result = await this.layer.saveAs(jsPortalItem,
            options);
        return await createGeoBlazorObject(result);
    }

    async updateAttachment(feature: any,
        attachmentId: any,
        attachment: any): Promise<any> {
        let { buildJsGraphic } = await import('./jsBuilder');
        let jsFeature = await buildJsGraphic(feature, this.geoblaz) as any;
        let result = await this.layer.updateAttachment(jsFeature,
            attachmentId,
            attachment);
        return await createGeoBlazorObject(result);
    }

    // region properties
    
    getProperty(prop: string): any {
        return this.layer[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.layer[prop] = value;
    }
    
    addToProperty(prop: string, value: any): void {
        if (Array.isArray(value)) {
            this.layer[prop].addMany(value);
        } else {
            this.layer[prop].add(value);
        }
    }
    
    removeFromProperty(prop: string, value: any): any {
        if (Array.isArray(value)) {
            this.layer[prop].removeMany(value);
        } else {
            this.layer[prop].remove(value);
        }
    }
}


export async function buildJsFeatureLayer(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let { default: FeatureLayer } = await import('@arcgis/core/layers/FeatureLayer');
    let jsFeatureLayer = new FeatureLayer();
    if (hasValue(dotNetObject.elevationInfo)) {
        jsFeatureLayer.elevationInfo = await buildJsFeatureLayerBaseElevationInfo(dotNetObject.elevationInfo) as any;
    }
    if (hasValue(dotNetObject.featureEffect)) {
        let { buildJsFeatureEffect } = await import('./jsBuilder');
        jsFeatureLayer.featureEffect = buildJsFeatureEffect(dotNetObject.featureEffect) as any;
    }
    if (hasValue(dotNetObject.fields)) {
        let { buildJsField } = await import('./jsBuilder');
        jsFeatureLayer.fields = dotNetObject.fields.map(i => buildJsField(i)) as any;
    }
    if (hasValue(dotNetObject.floorInfo)) {
        jsFeatureLayer.floorInfo = await buildJsLayerFloorInfo(dotNetObject.floorInfo) as any;
    }
    if (hasValue(dotNetObject.formTemplate)) {
        let { buildJsFormTemplate } = await import('./jsBuilder');
        jsFeatureLayer.formTemplate = buildJsFormTemplate(dotNetObject.formTemplate) as any;
    }
    if (hasValue(dotNetObject.fullExtent)) {
        let { buildJsExtent } = await import('./jsBuilder');
        jsFeatureLayer.fullExtent = buildJsExtent(dotNetObject.fullExtent) as any;
    }
    if (hasValue(dotNetObject.labelingInfo)) {
        jsFeatureLayer.labelingInfo = dotNetObject.labelingInfo.map(async i => await buildJsLabel(i)) as any;
    }
    if (hasValue(dotNetObject.orderBy)) {
        jsFeatureLayer.orderBy = dotNetObject.orderBy.map(async i => await buildJsOrderedLayerOrderBy(i)) as any;
    }
    if (hasValue(dotNetObject.popupTemplate)) {
        let { buildJsPopupTemplate } = await import('./jsBuilder');
        jsFeatureLayer.popupTemplate = buildJsPopupTemplate(dotNetObject.popupTemplate, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.portalItem)) {
        let { buildJsPortalItem } = await import('./jsBuilder');
        jsFeatureLayer.portalItem = buildJsPortalItem(dotNetObject.portalItem) as any;
    }
    if (hasValue(dotNetObject.renderer)) {
        let { buildJsRenderer } = await import('./jsBuilder');
        jsFeatureLayer.renderer = buildJsRenderer(dotNetObject.renderer) as any;
    }
    if (hasValue(dotNetObject.source)) {
        let { buildJsGraphic } = await import('./jsBuilder');
        jsFeatureLayer.source = dotNetObject.source.map(i => buildJsGraphic(i, layerId, viewId)) as any;
    }
    if (hasValue(dotNetObject.templates)) {
        let { buildJsFeatureTemplate } = await import('./jsBuilder');
        jsFeatureLayer.templates = dotNetObject.templates.map(i => buildJsFeatureTemplate(i, viewId)) as any;
    }
    if (hasValue(dotNetObject.timeExtent)) {
        jsFeatureLayer.timeExtent = await buildJsTimeExtent(dotNetObject.timeExtent) as any;
    }
    if (hasValue(dotNetObject.timeInfo)) {
        jsFeatureLayer.timeInfo = await buildJsTimeInfo(dotNetObject.timeInfo) as any;
    }
    if (hasValue(dotNetObject.timeOffset)) {
        jsFeatureLayer.timeOffset = await buildJsTimeInterval(dotNetObject.timeOffset) as any;
    }
    if (hasValue(dotNetObject.visibilityTimeExtent)) {
        jsFeatureLayer.visibilityTimeExtent = await buildJsTimeExtent(dotNetObject.visibilityTimeExtent) as any;
    }
    if (hasValue(dotNetObject.apiKey)) {
        jsFeatureLayer.apiKey = dotNetObject.apiKey;
    }
    if (hasValue(dotNetObject.arcGISLayerId)) {
        jsFeatureLayer.id = dotNetObject.arcGISLayerId;
    }
    if (hasValue(dotNetObject.blendMode)) {
        jsFeatureLayer.blendMode = dotNetObject.blendMode;
    }
    if (hasValue(dotNetObject.charts)) {
        jsFeatureLayer.charts = dotNetObject.charts;
    }
    if (hasValue(dotNetObject.copyright)) {
        jsFeatureLayer.copyright = dotNetObject.copyright;
    }
    if (hasValue(dotNetObject.customParameters)) {
        jsFeatureLayer.customParameters = dotNetObject.customParameters;
    }
    if (hasValue(dotNetObject.dateFieldsTimeZone)) {
        jsFeatureLayer.dateFieldsTimeZone = dotNetObject.dateFieldsTimeZone;
    }
    if (hasValue(dotNetObject.definitionExpression)) {
        jsFeatureLayer.definitionExpression = dotNetObject.definitionExpression;
    }
    if (hasValue(dotNetObject.displayField)) {
        jsFeatureLayer.displayField = dotNetObject.displayField;
    }
    if (hasValue(dotNetObject.dynamicDataSource)) {
        jsFeatureLayer.dynamicDataSource = dotNetObject.dynamicDataSource;
    }
    if (hasValue(dotNetObject.editingEnabled)) {
        jsFeatureLayer.editingEnabled = dotNetObject.editingEnabled;
    }
    if (hasValue(dotNetObject.effect)) {
        jsFeatureLayer.effect = dotNetObject.effect;
    }
    if (hasValue(dotNetObject.featureReduction)) {
        jsFeatureLayer.featureReduction = dotNetObject.featureReduction;
    }
    if (hasValue(dotNetObject.gdbVersion)) {
        jsFeatureLayer.gdbVersion = dotNetObject.gdbVersion;
    }
    if (hasValue(dotNetObject.geometryType)) {
        jsFeatureLayer.geometryType = dotNetObject.geometryType;
    }
    if (hasValue(dotNetObject.hasM)) {
        jsFeatureLayer.hasM = dotNetObject.hasM;
    }
    if (hasValue(dotNetObject.hasZ)) {
        jsFeatureLayer.hasZ = dotNetObject.hasZ;
    }
    if (hasValue(dotNetObject.historicMoment)) {
        jsFeatureLayer.historicMoment = dotNetObject.historicMoment;
    }
    if (hasValue(dotNetObject.labelsVisible)) {
        jsFeatureLayer.labelsVisible = dotNetObject.labelsVisible;
    }
    if (hasValue(dotNetObject.layerIndex)) {
        jsFeatureLayer.layerId = dotNetObject.layerIndex;
    }
    if (hasValue(dotNetObject.legendEnabled)) {
        jsFeatureLayer.legendEnabled = dotNetObject.legendEnabled;
    }
    if (hasValue(dotNetObject.listMode)) {
        jsFeatureLayer.listMode = dotNetObject.listMode;
    }
    if (hasValue(dotNetObject.maxScale)) {
        jsFeatureLayer.maxScale = dotNetObject.maxScale;
    }
    if (hasValue(dotNetObject.minScale)) {
        jsFeatureLayer.minScale = dotNetObject.minScale;
    }
    if (hasValue(dotNetObject.objectIdField)) {
        jsFeatureLayer.objectIdField = dotNetObject.objectIdField;
    }
    if (hasValue(dotNetObject.opacity)) {
        jsFeatureLayer.opacity = dotNetObject.opacity;
    }
    if (hasValue(dotNetObject.outFields)) {
        jsFeatureLayer.outFields = dotNetObject.outFields;
    }
    if (hasValue(dotNetObject.persistenceEnabled)) {
        jsFeatureLayer.persistenceEnabled = dotNetObject.persistenceEnabled;
    }
    if (hasValue(dotNetObject.popupEnabled)) {
        jsFeatureLayer.popupEnabled = dotNetObject.popupEnabled;
    }
    if (hasValue(dotNetObject.refreshInterval)) {
        jsFeatureLayer.refreshInterval = dotNetObject.refreshInterval;
    }
    if (hasValue(dotNetObject.returnM)) {
        jsFeatureLayer.returnM = dotNetObject.returnM;
    }
    if (hasValue(dotNetObject.returnZ)) {
        jsFeatureLayer.returnZ = dotNetObject.returnZ;
    }
    if (hasValue(dotNetObject.screenSizePerspectiveEnabled)) {
        jsFeatureLayer.screenSizePerspectiveEnabled = dotNetObject.screenSizePerspectiveEnabled;
    }
    if (hasValue(dotNetObject.sourceJSON)) {
        jsFeatureLayer.sourceJSON = dotNetObject.sourceJSON;
    }
    if (hasValue(dotNetObject.spatialReference)) {
        jsFeatureLayer.spatialReference = dotNetObject.spatialReference;
    }
    if (hasValue(dotNetObject.title)) {
        jsFeatureLayer.title = dotNetObject.title;
    }
    if (hasValue(dotNetObject.typeIdField)) {
        jsFeatureLayer.typeIdField = dotNetObject.typeIdField;
    }
    if (hasValue(dotNetObject.types)) {
        jsFeatureLayer.types = dotNetObject.types;
    }
    if (hasValue(dotNetObject.url)) {
        jsFeatureLayer.url = dotNetObject.url;
    }
    if (hasValue(dotNetObject.useViewTime)) {
        jsFeatureLayer.useViewTime = dotNetObject.useViewTime;
    }
    jsFeatureLayer.on('edits', async (evt: any) => {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsEdits', evt);
    });

    jsFeatureLayer.on('refresh', async (evt: any) => {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsRefresh', evt);
    });

    let { default: FeatureLayerWrapper } = await import('./featureLayer');
    let featureLayerWrapper = new FeatureLayerWrapper(jsFeatureLayer);
    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(featureLayerWrapper);
    await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef);
    jsObjectRefs[dotNetObject.id] = featureLayerWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsFeatureLayer;
    return jsFeatureLayer;
}

export async function getFeatureLayer()