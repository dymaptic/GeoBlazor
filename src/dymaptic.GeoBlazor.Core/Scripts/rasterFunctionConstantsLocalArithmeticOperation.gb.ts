// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import { arcGisObjectRefs, jsObjectRefs, hasValue, lookupGeoBlazorId } from './arcGisJsInterop';
import { buildDotNetRasterFunctionConstantsLocalArithmeticOperation } from './rasterFunctionConstantsLocalArithmeticOperation';

export async function buildJsRasterFunctionConstantsLocalArithmeticOperationGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsrasterFunctionConstantsLocalArithmeticOperation: any = {};

    if (hasValue(dotNetObject.abs)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.abs = dotNetObject.abs;
    }
    if (hasValue(dotNetObject.divide)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.divide = dotNetObject.divide;
    }
    if (hasValue(dotNetObject.exp)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.exp = dotNetObject.exp;
    }
    if (hasValue(dotNetObject.exp10)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.exp10 = dotNetObject.exp10;
    }
    if (hasValue(dotNetObject.exp2)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.exp2 = dotNetObject.exp2;
    }
    if (hasValue(dotNetObject.float)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.float = dotNetObject.float;
    }
    if (hasValue(dotNetObject.int)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.int = dotNetObject.int;
    }
    if (hasValue(dotNetObject.ln)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.ln = dotNetObject.ln;
    }
    if (hasValue(dotNetObject.log10)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.log10 = dotNetObject.log10;
    }
    if (hasValue(dotNetObject.log2)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.log2 = dotNetObject.log2;
    }
    if (hasValue(dotNetObject.minus)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.minus = dotNetObject.minus;
    }
    if (hasValue(dotNetObject.mod)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.mod = dotNetObject.mod;
    }
    if (hasValue(dotNetObject.negate)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.negate = dotNetObject.negate;
    }
    if (hasValue(dotNetObject.plus)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.plus = dotNetObject.plus;
    }
    if (hasValue(dotNetObject.power)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.power = dotNetObject.power;
    }
    if (hasValue(dotNetObject.roundDown)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.roundDown = dotNetObject.roundDown;
    }
    if (hasValue(dotNetObject.roundUp)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.roundUp = dotNetObject.roundUp;
    }
    if (hasValue(dotNetObject.sqrt)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.sqrt = dotNetObject.sqrt;
    }
    if (hasValue(dotNetObject.square)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.square = dotNetObject.square;
    }
    if (hasValue(dotNetObject.times)) {
        jsrasterFunctionConstantsLocalArithmeticOperation.times = dotNetObject.times;
    }
    
    let jsObjectRef = DotNet.createJSObjectReference(jsrasterFunctionConstantsLocalArithmeticOperation);
    jsObjectRefs[dotNetObject.id] = jsObjectRef;
    arcGisObjectRefs[dotNetObject.id] = jsrasterFunctionConstantsLocalArithmeticOperation;
    
    let { buildDotNetRasterFunctionConstantsLocalArithmeticOperation } = await import('./rasterFunctionConstantsLocalArithmeticOperation');
    let dnInstantiatedObject = await buildDotNetRasterFunctionConstantsLocalArithmeticOperation(jsrasterFunctionConstantsLocalArithmeticOperation);

    try {
        let seenObjects = new WeakMap();
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', 
            jsObjectRef, JSON.stringify(dnInstantiatedObject, function (key, value) {
                if (key.startsWith('_') || key === 'jsComponentReference') {
                    return undefined;
                }
                if (typeof value === 'object' && value !== null
                    && !(Array.isArray(value) && value.length === 0)) {
                    if (seenObjects.has(value)) {
                        console.debug(`Circular reference in serializing type RasterFunctionConstantsLocalArithmeticOperation detected at path: ${key}, value: ${value.declaredClass}`);
                        return undefined;
                    }
                    seenObjects.set(value, true);
                }
                return value;
            }));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for RasterFunctionConstantsLocalArithmeticOperation', e);
    }
    
    return jsrasterFunctionConstantsLocalArithmeticOperation;
}


export async function buildDotNetRasterFunctionConstantsLocalArithmeticOperationGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetRasterFunctionConstantsLocalArithmeticOperation: any = {
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };
    if (hasValue(jsObject.abs)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.abs = jsObject.abs;
    }
    if (hasValue(jsObject.divide)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.divide = jsObject.divide;
    }
    if (hasValue(jsObject.exp)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.exp = jsObject.exp;
    }
    if (hasValue(jsObject.exp10)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.exp10 = jsObject.exp10;
    }
    if (hasValue(jsObject.exp2)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.exp2 = jsObject.exp2;
    }
    if (hasValue(jsObject.float)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.float = jsObject.float;
    }
    if (hasValue(jsObject.int)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.int = jsObject.int;
    }
    if (hasValue(jsObject.ln)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.ln = jsObject.ln;
    }
    if (hasValue(jsObject.log10)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.log10 = jsObject.log10;
    }
    if (hasValue(jsObject.log2)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.log2 = jsObject.log2;
    }
    if (hasValue(jsObject.minus)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.minus = jsObject.minus;
    }
    if (hasValue(jsObject.mod)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.mod = jsObject.mod;
    }
    if (hasValue(jsObject.negate)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.negate = jsObject.negate;
    }
    if (hasValue(jsObject.plus)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.plus = jsObject.plus;
    }
    if (hasValue(jsObject.power)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.power = jsObject.power;
    }
    if (hasValue(jsObject.roundDown)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.roundDown = jsObject.roundDown;
    }
    if (hasValue(jsObject.roundUp)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.roundUp = jsObject.roundUp;
    }
    if (hasValue(jsObject.sqrt)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.sqrt = jsObject.sqrt;
    }
    if (hasValue(jsObject.square)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.square = jsObject.square;
    }
    if (hasValue(jsObject.times)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.times = jsObject.times;
    }

    let geoBlazorId = lookupGeoBlazorId(jsObject);
    if (hasValue(geoBlazorId)) {
        dotNetRasterFunctionConstantsLocalArithmeticOperation.id = geoBlazorId;
    }

    return dotNetRasterFunctionConstantsLocalArithmeticOperation;
}

