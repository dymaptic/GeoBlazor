// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file
import ArcGISImageService = __esri.ArcGISImageService;
import {arcGisObjectRefs, hasValue, jsObjectRefs} from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class IArcGISImageServiceGenerated implements IPropertyWrapper {
    public component: ArcGISImageService;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: ArcGISImageService) {
        this.component = component;
    }

    // region methods

    unwrap() {
        return this.component;
    }

    async computeAngles(parameters: any,
                        requestOptions: any): Promise<any> {
        let {buildJsImageAngleParameters} = await import('./imageAngleParameters');
        let jsParameters = await buildJsImageAngleParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.computeAngles(jsParameters,
            requestOptions);
    }

    async computeHistograms(parameters: any,
                            requestOptions: any): Promise<any> {
        let {buildJsImageHistogramParameters} = await import('./imageHistogramParameters');
        let jsParameters = await buildJsImageHistogramParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.computeHistograms(jsParameters,
            requestOptions);
    }

    async computePixelSpaceLocations(parameters: any,
                                     requestOptions: any): Promise<any> {
        let {buildJsImagePixelLocationParameters} = await import('./imagePixelLocationParameters');
        let jsParameters = await buildJsImagePixelLocationParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.computePixelSpaceLocations(jsParameters,
            requestOptions);
    }

    async computeStatisticsHistograms(parameters: any,
                                      requestOptions: any): Promise<any> {
        let {buildJsImageHistogramParameters} = await import('./imageHistogramParameters');
        let jsParameters = await buildJsImageHistogramParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.computeStatisticsHistograms(jsParameters,
            requestOptions);
    }

    async fetchImage(extent: any,
                     width: any,
                     height: any,
                     options: any): Promise<any> {
        let {buildJsExtent} = await import('./extent');
        let jsExtent = buildJsExtent(extent) as any;
        return await this.component.fetchImage(jsExtent,
            width,
            height,
            options);
    }

    async findImages(parameters: any,
                     requestOptions: any): Promise<any> {
        let {buildJsFindImagesParameters} = await import('./findImagesParameters');
        let jsParameters = await buildJsFindImagesParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.findImages(jsParameters,
            requestOptions);
    }

    async generateRasterInfo(rasterFunction: any,
                             options: any): Promise<any> {
        return await this.component.generateRasterInfo(rasterFunction,
            options);
    }

    async getCatalogItemICSInfo(rasterId: any,
                                options: any): Promise<any> {
        return await this.component.getCatalogItemICSInfo(rasterId,
            options);
    }

    async getCatalogItemRasterInfo(rasterId: any,
                                   options: any): Promise<any> {
        return await this.component.getCatalogItemRasterInfo(rasterId,
            options);
    }

    async getImageUrl(parameters: any,
                      requestOptions: any): Promise<any> {
        return await this.component.getImageUrl(parameters,
            requestOptions);
    }

    async getSamples(parameters: any,
                     requestOptions: any): Promise<any> {
        let {buildJsImageSampleParameters} = await import('./imageSampleParameters');
        let jsParameters = await buildJsImageSampleParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.getSamples(jsParameters,
            requestOptions);
    }

    async identify(parameters: any,
                   requestOptions: any): Promise<any> {
        let {buildJsImageIdentifyParameters} = await import('./imageIdentifyParameters');
        let jsParameters = await buildJsImageIdentifyParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.identify(jsParameters,
            requestOptions);
    }

    async imageToMap(parameters: any,
                     requestOptions: any): Promise<any> {
        let {buildJsImageToMapParameters} = await import('./imageToMapParameters');
        let jsParameters = await buildJsImageToMapParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.imageToMap(jsParameters,
            requestOptions);
    }

    async imageToMapMultiray(parameters: any,
                             requestOptions: any): Promise<any> {
        let {buildJsImageToMapMultirayParameters} = await import('./imageToMapMultirayParameters');
        let jsParameters = await buildJsImageToMapMultirayParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.imageToMapMultiray(jsParameters,
            requestOptions);
    }

    async mapToImage(parameters: any,
                     requestOptions: any): Promise<any> {
        let {buildJsMapToImageParameters} = await import('./mapToImageParameters');
        let jsParameters = await buildJsMapToImageParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.mapToImage(jsParameters,
            requestOptions);
    }

    async measureAreaAndPerimeter(parameters: any,
                                  requestOptions: any): Promise<any> {
        let {buildJsImageAreaParameters} = await import('./imageAreaParameters');
        let jsParameters = await buildJsImageAreaParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.measureAreaAndPerimeter(jsParameters,
            requestOptions);
    }

    async measureAreaFromImage(parameters: any,
                               requestOptions: any): Promise<any> {
        let {buildJsMeasureFromImageParameters} = await import('./measureFromImageParameters');
        let jsParameters = await buildJsMeasureFromImageParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.measureAreaFromImage(jsParameters,
            requestOptions);
    }

    async measureDistanceAndAngle(parameters: any,
                                  requestOptions: any): Promise<any> {
        let {buildJsImageDistanceParameters} = await import('./imageDistanceParameters');
        let jsParameters = await buildJsImageDistanceParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.measureDistanceAndAngle(jsParameters,
            requestOptions);
    }

    async measureHeight(parameters: any,
                        requestOptions: any): Promise<any> {
        let {buildJsImageHeightParameters} = await import('./imageHeightParameters');
        let jsParameters = await buildJsImageHeightParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.measureHeight(jsParameters,
            requestOptions);
    }

    async measureLengthFromImage(parameters: any,
                                 requestOptions: any): Promise<any> {
        let {buildJsMeasureFromImageParameters} = await import('./measureFromImageParameters');
        let jsParameters = await buildJsMeasureFromImageParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.measureLengthFromImage(jsParameters,
            requestOptions);
    }

    async measurePointOrCentroid(parameters: any,
                                 requestOptions: any): Promise<any> {
        let {buildJsImagePointParameters} = await import('./imagePointParameters');
        let jsParameters = await buildJsImagePointParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.measurePointOrCentroid(jsParameters,
            requestOptions);
    }

    async queryBoundary(parameters: any,
                        requestOptions: any): Promise<any> {
        let {buildJsImageBoundaryParameters} = await import('./imageBoundaryParameters');
        let jsParameters = await buildJsImageBoundaryParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.queryBoundary(jsParameters,
            requestOptions);
    }

    async queryGPSInfo(parameters: any,
                       requestOptions: any): Promise<any> {
        let {buildJsImageGPSInfoParameters} = await import('./imageGPSInfoParameters');
        let jsParameters = await buildJsImageGPSInfoParameters(parameters, this.layerId, this.viewId) as any;
        return await this.component.queryGPSInfo(jsParameters,
            requestOptions);
    }

    async queryObjectIds(query: any,
                         requestOptions: any): Promise<any> {
        let {buildJsQuery} = await import('./query');
        let jsQuery = await buildJsQuery(query, this.layerId, this.viewId) as any;
        return await this.component.queryObjectIds(jsQuery,
            requestOptions);
    }

    async queryRasterCount(query: any,
                           requestOptions: any): Promise<any> {
        let {buildJsQuery} = await import('./query');
        let jsQuery = await buildJsQuery(query, this.layerId, this.viewId) as any;
        return await this.component.queryRasterCount(jsQuery,
            requestOptions);
    }

    async queryRasters(query: any,
                       requestOptions: any): Promise<any> {
        let {buildJsQuery} = await import('./query');
        let jsQuery = await buildJsQuery(query, this.layerId, this.viewId) as any;
        return await this.component.queryRasters(jsQuery,
            requestOptions);
    }

    // region properties

    async getDefaultMosaicRule(): Promise<any> {
        if (!hasValue(this.component.defaultMosaicRule)) {
            return null;
        }

        let {buildDotNetMosaicRule} = await import('./mosaicRule');
        return await buildDotNetMosaicRule(this.component.defaultMosaicRule);
    }

    async getFields(): Promise<any> {
        if (!hasValue(this.component.fields)) {
            return null;
        }

        let {buildDotNetField} = await import('./field');
        return this.component.fields!.map(i => buildDotNetField(i));
    }

    async setFields(value: any): Promise<void> {
        let {buildJsField} = await import('./field');
        this.component.fields = value.map(i => buildJsField(i)) as any;
    }

    async getFieldsIndex(): Promise<any> {
        if (!hasValue(this.component.fieldsIndex)) {
            return null;
        }

        let {buildDotNetFieldsIndex} = await import('./fieldsIndex');
        return await buildDotNetFieldsIndex(this.component.fieldsIndex);
    }

    async getMosaicRule(): Promise<any> {
        if (!hasValue(this.component.mosaicRule)) {
            return null;
        }

        let {buildDotNetMosaicRule} = await import('./mosaicRule');
        return await buildDotNetMosaicRule(this.component.mosaicRule);
    }

    async setMosaicRule(value: any): Promise<void> {
        let {buildJsMosaicRule} = await import('./mosaicRule');
        this.component.mosaicRule = await buildJsMosaicRule(value, this.layerId, this.viewId);
    }

    async getMultidimensionalSubset(): Promise<any> {
        if (!hasValue(this.component.multidimensionalSubset)) {
            return null;
        }

        let {buildDotNetMultidimensionalSubset} = await import('./multidimensionalSubset');
        return await buildDotNetMultidimensionalSubset(this.component.multidimensionalSubset);
    }

    async setMultidimensionalSubset(value: any): Promise<void> {
        let {buildJsMultidimensionalSubset} = await import('./multidimensionalSubset');
        this.component.multidimensionalSubset = await buildJsMultidimensionalSubset(value, this.layerId, this.viewId);
    }

    async getRasterFields(): Promise<any> {
        if (!hasValue(this.component.rasterFields)) {
            return null;
        }

        let {buildDotNetField} = await import('./field');
        return this.component.rasterFields!.map(i => buildDotNetField(i));
    }

    async getServiceRasterInfo(): Promise<any> {
        if (!hasValue(this.component.serviceRasterInfo)) {
            return null;
        }

        let {buildDotNetRasterInfo} = await import('./rasterInfo');
        return await buildDotNetRasterInfo(this.component.serviceRasterInfo);
    }

    async getSpatialReference(): Promise<any> {
        if (!hasValue(this.component.spatialReference)) {
            return null;
        }

        let {buildDotNetSpatialReference} = await import('./spatialReference');
        return buildDotNetSpatialReference(this.component.spatialReference);
    }

    getProperty(prop: string): any {
        return this.component[prop];
    }

    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}

export async function buildJsIArcGISImageServiceGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsArcGISImageService = new ArcGISImageService();
    if (hasValue(dotNetObject.fields)) {
        let {buildJsField} = await import('./field');
        jsArcGISImageService.fields = dotNetObject.fields.map(i => buildJsField(i)) as any;
    }
    if (hasValue(dotNetObject.mosaicRule)) {
        let {buildJsMosaicRule} = await import('./mosaicRule');
        jsArcGISImageService.mosaicRule = await buildJsMosaicRule(dotNetObject.mosaicRule, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.multidimensionalSubset)) {
        let {buildJsMultidimensionalSubset} = await import('./multidimensionalSubset');
        jsArcGISImageService.multidimensionalSubset = await buildJsMultidimensionalSubset(dotNetObject.multidimensionalSubset, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.hasPixelFilter) && dotNetObject.hasPixelFilter) {
        jsArcGISImageService.pixelFilter = (pixelData) => {
            dotNetObject.dotNetObjectReference.invokeMethodAsync('OnJsPixelFilter', pixelData);
        };
    }

    if (hasValue(dotNetObject.bandIds)) {
        jsArcGISImageService.bandIds = dotNetObject.bandIds;
    }
    if (hasValue(dotNetObject.capabilities)) {
        const {id, dotNetComponentReference, layerId, viewId, ...sanitizedCapabilities} = dotNetObject.capabilities;
        jsArcGISImageService.capabilities = sanitizedCapabilities;
    }
    if (hasValue(dotNetObject.compressionQuality)) {
        jsArcGISImageService.compressionQuality = dotNetObject.compressionQuality;
    }
    if (hasValue(dotNetObject.compressionTolerance)) {
        jsArcGISImageService.compressionTolerance = dotNetObject.compressionTolerance;
    }
    if (hasValue(dotNetObject.copyright)) {
        jsArcGISImageService.copyright = dotNetObject.copyright;
    }
    if (hasValue(dotNetObject.definitionExpression)) {
        jsArcGISImageService.definitionExpression = dotNetObject.definitionExpression;
    }
    if (hasValue(dotNetObject.format)) {
        jsArcGISImageService.format = dotNetObject.format;
    }
    if (hasValue(dotNetObject.hasMultidimensions)) {
        jsArcGISImageService.hasMultidimensions = dotNetObject.hasMultidimensions;
    }
    if (hasValue(dotNetObject.imageMaxHeight)) {
        jsArcGISImageService.imageMaxHeight = dotNetObject.imageMaxHeight;
    }
    if (hasValue(dotNetObject.imageMaxWidth)) {
        jsArcGISImageService.imageMaxWidth = dotNetObject.imageMaxWidth;
    }
    if (hasValue(dotNetObject.interpolation)) {
        jsArcGISImageService.interpolation = dotNetObject.interpolation;
    }
    if (hasValue(dotNetObject.noData)) {
        jsArcGISImageService.noData = dotNetObject.noData;
    }
    if (hasValue(dotNetObject.noDataInterpretation)) {
        jsArcGISImageService.noDataInterpretation = dotNetObject.noDataInterpretation;
    }
    if (hasValue(dotNetObject.objectIdField)) {
        jsArcGISImageService.objectIdField = dotNetObject.objectIdField;
    }
    if (hasValue(dotNetObject.pixelType)) {
        jsArcGISImageService.pixelType = dotNetObject.pixelType;
    }
    if (hasValue(dotNetObject.rasterFunction)) {
        const {id, dotNetComponentReference, layerId, viewId, ...sanitizedRasterFunction} = dotNetObject.rasterFunction;
        jsArcGISImageService.rasterFunction = sanitizedRasterFunction;
    }
    if (hasValue(dotNetObject.renderer)) {
        jsArcGISImageService.renderer = dotNetObject.renderer;
    }
    if (hasValue(dotNetObject.renderingRule)) {
        const {id, dotNetComponentReference, layerId, viewId, ...sanitizedRenderingRule} = dotNetObject.renderingRule;
        jsArcGISImageService.renderingRule = sanitizedRenderingRule;
    }
    if (hasValue(dotNetObject.sourceJSON)) {
        jsArcGISImageService.sourceJSON = dotNetObject.sourceJSON;
    }
    if (hasValue(dotNetObject.url)) {
        jsArcGISImageService.url = dotNetObject.url;
    }

    let {default: IArcGISImageServiceWrapper} = await import('./iArcGISImageService');
    let iArcGISImageServiceWrapper = new IArcGISImageServiceWrapper(jsArcGISImageService);
    iArcGISImageServiceWrapper.geoBlazorId = dotNetObject.id;
    iArcGISImageServiceWrapper.viewId = viewId;
    iArcGISImageServiceWrapper.layerId = layerId;

    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(iArcGISImageServiceWrapper);
    jsObjectRefs[dotNetObject.id] = iArcGISImageServiceWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsArcGISImageService;
    let {buildDotNetIArcGISImageService} = await import('./iArcGISImageService');
    let dnInstantiatedObject = await buildDotNetIArcGISImageService(jsArcGISImageService);

    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for IArcGISImageService', e);
    }

    return jsArcGISImageService;
}

export async function buildDotNetIArcGISImageServiceGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }

    let dotNetIArcGISImageService: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };
    if (hasValue(jsObject.defaultMosaicRule)) {
        let {buildDotNetMosaicRule} = await import('./mosaicRule');
        dotNetIArcGISImageService.defaultMosaicRule = await buildDotNetMosaicRule(jsObject.defaultMosaicRule);
    }
    if (hasValue(jsObject.fields)) {
        let {buildDotNetField} = await import('./field');
        dotNetIArcGISImageService.fields = jsObject.fields.map(i => buildDotNetField(i));
    }
    if (hasValue(jsObject.fieldsIndex)) {
        let {buildDotNetFieldsIndex} = await import('./fieldsIndex');
        dotNetIArcGISImageService.fieldsIndex = await buildDotNetFieldsIndex(jsObject.fieldsIndex);
    }
    if (hasValue(jsObject.mosaicRule)) {
        let {buildDotNetMosaicRule} = await import('./mosaicRule');
        dotNetIArcGISImageService.mosaicRule = await buildDotNetMosaicRule(jsObject.mosaicRule);
    }
    if (hasValue(jsObject.multidimensionalSubset)) {
        let {buildDotNetMultidimensionalSubset} = await import('./multidimensionalSubset');
        dotNetIArcGISImageService.multidimensionalSubset = await buildDotNetMultidimensionalSubset(jsObject.multidimensionalSubset);
    }
    if (hasValue(jsObject.rasterFields)) {
        let {buildDotNetField} = await import('./field');
        dotNetIArcGISImageService.rasterFields = jsObject.rasterFields.map(i => buildDotNetField(i));
    }
    if (hasValue(jsObject.serviceRasterInfo)) {
        let {buildDotNetRasterInfo} = await import('./rasterInfo');
        dotNetIArcGISImageService.serviceRasterInfo = await buildDotNetRasterInfo(jsObject.serviceRasterInfo);
    }
    if (hasValue(jsObject.spatialReference)) {
        let {buildDotNetSpatialReference} = await import('./spatialReference');
        dotNetIArcGISImageService.spatialReference = buildDotNetSpatialReference(jsObject.spatialReference);
    }
    if (hasValue(jsObject.bandIds)) {
        dotNetIArcGISImageService.bandIds = jsObject.bandIds;
    }
    if (hasValue(jsObject.capabilities)) {
        dotNetIArcGISImageService.capabilities = jsObject.capabilities;
    }
    if (hasValue(jsObject.compressionQuality)) {
        dotNetIArcGISImageService.compressionQuality = jsObject.compressionQuality;
    }
    if (hasValue(jsObject.compressionTolerance)) {
        dotNetIArcGISImageService.compressionTolerance = jsObject.compressionTolerance;
    }
    if (hasValue(jsObject.copyright)) {
        dotNetIArcGISImageService.copyright = jsObject.copyright;
    }
    if (hasValue(jsObject.definitionExpression)) {
        dotNetIArcGISImageService.definitionExpression = jsObject.definitionExpression;
    }
    if (hasValue(jsObject.format)) {
        dotNetIArcGISImageService.format = jsObject.format;
    }
    if (hasValue(jsObject.hasMultidimensions)) {
        dotNetIArcGISImageService.hasMultidimensions = jsObject.hasMultidimensions;
    }
    if (hasValue(jsObject.imageMaxHeight)) {
        dotNetIArcGISImageService.imageMaxHeight = jsObject.imageMaxHeight;
    }
    if (hasValue(jsObject.imageMaxWidth)) {
        dotNetIArcGISImageService.imageMaxWidth = jsObject.imageMaxWidth;
    }
    if (hasValue(jsObject.interpolation)) {
        dotNetIArcGISImageService.interpolation = jsObject.interpolation;
    }
    if (hasValue(jsObject.multidimensionalInfo)) {
        dotNetIArcGISImageService.multidimensionalInfo = jsObject.multidimensionalInfo;
    }
    if (hasValue(jsObject.noData)) {
        dotNetIArcGISImageService.noData = jsObject.noData;
    }
    if (hasValue(jsObject.noDataInterpretation)) {
        dotNetIArcGISImageService.noDataInterpretation = jsObject.noDataInterpretation;
    }
    if (hasValue(jsObject.objectIdField)) {
        dotNetIArcGISImageService.objectIdField = jsObject.objectIdField;
    }
    if (hasValue(jsObject.pixelFilter)) {
        dotNetIArcGISImageService.pixelFilter = jsObject.pixelFilter;
    }
    if (hasValue(jsObject.pixelType)) {
        dotNetIArcGISImageService.pixelType = jsObject.pixelType;
    }
    if (hasValue(jsObject.rasterFunction)) {
        dotNetIArcGISImageService.rasterFunction = jsObject.rasterFunction;
    }
    if (hasValue(jsObject.rasterFunctionInfos)) {
        dotNetIArcGISImageService.rasterFunctionInfos = jsObject.rasterFunctionInfos;
    }
    if (hasValue(jsObject.renderer)) {
        dotNetIArcGISImageService.renderer = jsObject.renderer;
    }
    if (hasValue(jsObject.renderingRule)) {
        dotNetIArcGISImageService.renderingRule = jsObject.renderingRule;
    }
    if (hasValue(jsObject.sourceJSON)) {
        dotNetIArcGISImageService.sourceJSON = jsObject.sourceJSON;
    }
    if (hasValue(jsObject.sourceType)) {
        dotNetIArcGISImageService.sourceType = jsObject.sourceType;
    }
    if (hasValue(jsObject.url)) {
        dotNetIArcGISImageService.url = jsObject.url;
    }
    if (hasValue(jsObject.version)) {
        dotNetIArcGISImageService.version = jsObject.version;
    }

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetIArcGISImageService.id = k;
                break;
            }
        }
    }

    return dotNetIArcGISImageService;
}

