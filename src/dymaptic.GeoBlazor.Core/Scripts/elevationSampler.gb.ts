// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import ElevationSampler = __esri.ElevationSampler;
import { arcGisObjectRefs, jsObjectRefs, hasValue } from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class ElevationSamplerGenerated implements IPropertyWrapper {
    public component: ElevationSampler;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: ElevationSampler) {
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    
    async elevationAt(x: any,
        y: any): Promise<any> {
        return this.component.elevationAt(x,
            y);
    }

    async queryElevation(geometry: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return this.component.queryElevation(jsGeometry);
    }

    // region properties
    
    async getExtent(): Promise<any> {
        if (!hasValue(this.component.extent)) {
            return null;
        }
        
        let { buildDotNetExtent } = await import('./extent');
        return buildDotNetExtent(this.component.extent);
    }
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}


export async function buildJsElevationSamplerGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsElevationSampler: any = {};

    jsElevationSampler.on('changed', async (evt: any) => {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsChanged', evt);
    });
    

    let { default: ElevationSamplerWrapper } = await import('./elevationSampler');
    let elevationSamplerWrapper = new ElevationSamplerWrapper(jsElevationSampler);
    elevationSamplerWrapper.geoBlazorId = dotNetObject.id;
    elevationSamplerWrapper.viewId = viewId;
    elevationSamplerWrapper.layerId = layerId;
    
    let jsObjectRef = DotNet.createJSObjectReference(elevationSamplerWrapper);
    jsObjectRefs[dotNetObject.id] = elevationSamplerWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsElevationSampler;
    
    return jsElevationSampler;
}


export async function buildDotNetElevationSamplerGenerated(jsObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetElevationSampler: any = {};
    
    if (hasValue(jsObject.extent)) {
        let { buildDotNetExtent } = await import('./extent');
        dotNetElevationSampler.extent = buildDotNetExtent(jsObject.extent);
    }
    
    if (hasValue(jsObject.demResolution)) {
        dotNetElevationSampler.demResolution = jsObject.demResolution;
    }
    
    if (hasValue(jsObject.noDataValue)) {
        dotNetElevationSampler.noDataValue = jsObject.noDataValue;
    }
    
    if (hasValue(jsObject.spatialReference)) {
        dotNetElevationSampler.spatialReference = jsObject.spatialReference;
    }
    

    return dotNetElevationSampler;
}

