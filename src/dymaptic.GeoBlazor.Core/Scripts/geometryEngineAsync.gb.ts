// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import geometryEngineAsync = __esri.geometryEngineAsync;
import { arcGisObjectRefs, jsObjectRefs, hasValue, lookupGeoBlazorId } from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class GeometryEngineAsyncGenerated implements IPropertyWrapper {
    public component: geometryEngineAsync;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: geometryEngineAsync) {
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    

    async updateComponent(dotNetObject: any): Promise<void> {

    }
    
    async buffer(geometry: any,
        distance: any,
        unit: any,
        unionResults: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.buffer(jsGeometry,
            distance,
            unit,
            unionResults);
    }

    async clip(geometry: any,
        envelope: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        let { buildJsExtent } = await import('./extent');
        let jsEnvelope = buildJsExtent(envelope) as any;
        return await this.component.clip(jsGeometry,
            jsEnvelope);
    }

    async contains(containerGeometry: any,
        insideGeometry: any): Promise<any> {
        let jsContainerGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsContainerGeometry = buildJsGeometry(containerGeometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsContainerGeometry = null;
        }
        let jsInsideGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsInsideGeometry = buildJsGeometry(insideGeometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsInsideGeometry = null;
        }
        return await this.component.contains(jsContainerGeometry,
            jsInsideGeometry);
    }

    async convexHull(geometry: any,
        merge: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.convexHull(jsGeometry,
            merge);
    }

    async crosses(geometry1: any,
        geometry2: any): Promise<any> {
        let jsGeometry1: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry1 = buildJsGeometry(geometry1) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry1 = null;
        }
        let jsGeometry2: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry2 = buildJsGeometry(geometry2) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry2 = null;
        }
        return await this.component.crosses(jsGeometry1,
            jsGeometry2);
    }

    async cut(geometry: any,
        cutter: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        let { buildJsPolyline } = await import('./polyline');
        let jsCutter = buildJsPolyline(cutter) as any;
        return await this.component.cut(jsGeometry,
            jsCutter);
    }

    async densify(geometry: any,
        maxSegmentLength: any,
        maxSegmentLengthUnit: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.densify(jsGeometry,
            maxSegmentLength,
            maxSegmentLengthUnit);
    }

    async difference(inputGeometry: any,
        subtractor: any): Promise<any> {
        let jsInputGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsInputGeometry = buildJsGeometry(inputGeometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsInputGeometry = null;
        }
        let jsSubtractor: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsSubtractor = buildJsGeometry(subtractor) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsSubtractor = null;
        }
        return await this.component.difference(jsInputGeometry,
            jsSubtractor);
    }

    async disjoint(geometry1: any,
        geometry2: any): Promise<any> {
        let jsGeometry1: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry1 = buildJsGeometry(geometry1) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry1 = null;
        }
        let jsGeometry2: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry2 = buildJsGeometry(geometry2) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry2 = null;
        }
        return await this.component.disjoint(jsGeometry1,
            jsGeometry2);
    }

    async distance(geometry1: any,
        geometry2: any,
        distanceUnit: any): Promise<any> {
        let jsGeometry1: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry1 = buildJsGeometry(geometry1) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry1 = null;
        }
        let jsGeometry2: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry2 = buildJsGeometry(geometry2) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry2 = null;
        }
        return await this.component.distance(jsGeometry1,
            jsGeometry2,
            distanceUnit);
    }

    async extendedSpatialReferenceInfo(spatialReference: any): Promise<any> {
        return await this.component.extendedSpatialReferenceInfo(spatialReference);
    }

    async flipHorizontal(geometry: any,
        flipOrigin: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        let { buildJsPoint } = await import('./point');
        let jsFlipOrigin = buildJsPoint(flipOrigin) as any;
        return await this.component.flipHorizontal(jsGeometry,
            jsFlipOrigin);
    }

    async flipVertical(geometry: any,
        flipOrigin: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        let { buildJsPoint } = await import('./point');
        let jsFlipOrigin = buildJsPoint(flipOrigin) as any;
        return await this.component.flipVertical(jsGeometry,
            jsFlipOrigin);
    }

    async generalize(geometry: any,
        maxDeviation: any,
        removeDegenerateParts: any,
        maxDeviationUnit: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.generalize(jsGeometry,
            maxDeviation,
            removeDegenerateParts,
            maxDeviationUnit);
    }

    async geodesicArea(geometry: any,
        unit: any): Promise<any> {
        let { buildJsPolygon } = await import('./polygon');
        let jsGeometry = buildJsPolygon(geometry) as any;
        return await this.component.geodesicArea(jsGeometry,
            unit);
    }

    async geodesicBuffer(geometry: any,
        distance: any,
        unit: any,
        unionResults: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.geodesicBuffer(jsGeometry,
            distance,
            unit,
            unionResults);
    }

    async geodesicDensify(geometry: any,
        maxSegmentLength: any,
        maxSegmentLengthUnit: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.geodesicDensify(jsGeometry,
            maxSegmentLength,
            maxSegmentLengthUnit);
    }

    async geodesicLength(geometry: any,
        unit: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.geodesicLength(jsGeometry,
            unit);
    }

    async intersect(geometry1: any,
        geometry2: any): Promise<any> {
        let jsGeometry1: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry1 = buildJsGeometry(geometry1) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry1 = null;
        }
        let jsGeometry2: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry2 = buildJsGeometry(geometry2) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry2 = null;
        }
        return await this.component.intersect(jsGeometry1,
            jsGeometry2);
    }

    async intersectLinesToPoints(line1: any,
        line2: any): Promise<any> {
        let { buildJsPolyline } = await import('./polyline');
        let jsLine1 = buildJsPolyline(line1) as any;
        let jsLine2 = buildJsPolyline(line2) as any;
        return await this.component.intersectLinesToPoints(jsLine1,
            jsLine2);
    }

    async intersects(geometry1: any,
        geometry2: any): Promise<any> {
        let jsGeometry1: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry1 = buildJsGeometry(geometry1) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry1 = null;
        }
        let jsGeometry2: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry2 = buildJsGeometry(geometry2) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry2 = null;
        }
        return await this.component.intersects(jsGeometry1,
            jsGeometry2);
    }

    async isSimple(geometry: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.isSimple(jsGeometry);
    }

    async nearestCoordinate(geometry: any,
        inputPoint: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        let { buildJsPoint } = await import('./point');
        let jsInputPoint = buildJsPoint(inputPoint) as any;
        return await this.component.nearestCoordinate(jsGeometry,
            jsInputPoint);
    }

    async nearestVertex(geometry: any,
        inputPoint: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        let { buildJsPoint } = await import('./point');
        let jsInputPoint = buildJsPoint(inputPoint) as any;
        return await this.component.nearestVertex(jsGeometry,
            jsInputPoint);
    }

    async nearestVertices(geometry: any,
        inputPoint: any,
        searchRadius: any,
        maxVertexCountToReturn: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        let { buildJsPoint } = await import('./point');
        let jsInputPoint = buildJsPoint(inputPoint) as any;
        return await this.component.nearestVertices(jsGeometry,
            jsInputPoint,
            searchRadius,
            maxVertexCountToReturn);
    }

    async offset(geometry: any,
        offsetDistance: any,
        offsetUnit: any,
        joinType: any,
        bevelRatio: any,
        flattenError: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.offset(jsGeometry,
            offsetDistance,
            offsetUnit,
            joinType,
            bevelRatio,
            flattenError);
    }

    async overlaps(geometry1: any,
        geometry2: any): Promise<any> {
        let jsGeometry1: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry1 = buildJsGeometry(geometry1) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry1 = null;
        }
        let jsGeometry2: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry2 = buildJsGeometry(geometry2) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry2 = null;
        }
        return await this.component.overlaps(jsGeometry1,
            jsGeometry2);
    }

    async planarArea(geometry: any,
        unit: any): Promise<any> {
        let { buildJsPolygon } = await import('./polygon');
        let jsGeometry = buildJsPolygon(geometry) as any;
        return await this.component.planarArea(jsGeometry,
            unit);
    }

    async planarLength(geometry: any,
        unit: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.planarLength(jsGeometry,
            unit);
    }

    async relate(geometry1: any,
        geometry2: any,
        relation: any): Promise<any> {
        let jsGeometry1: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry1 = buildJsGeometry(geometry1) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry1 = null;
        }
        let jsGeometry2: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry2 = buildJsGeometry(geometry2) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry2 = null;
        }
        return await this.component.relate(jsGeometry1,
            jsGeometry2,
            relation);
    }

    async rotate(geometry: any,
        angle: any,
        rotationOrigin: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        let { buildJsPoint } = await import('./point');
        let jsRotationOrigin = buildJsPoint(rotationOrigin) as any;
        return await this.component.rotate(jsGeometry,
            angle,
            jsRotationOrigin);
    }

    async simplify(geometry: any): Promise<any> {
        let jsGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry = buildJsGeometry(geometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry = null;
        }
        return await this.component.simplify(jsGeometry);
    }

    async symmetricDifference(leftGeometry: any,
        rightGeometry: any): Promise<any> {
        let jsLeftGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsLeftGeometry = buildJsGeometry(leftGeometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsLeftGeometry = null;
        }
        let jsRightGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsRightGeometry = buildJsGeometry(rightGeometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsRightGeometry = null;
        }
        return await this.component.symmetricDifference(jsLeftGeometry,
            jsRightGeometry);
    }

    async touches(geometry1: any,
        geometry2: any): Promise<any> {
        let jsGeometry1: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry1 = buildJsGeometry(geometry1) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry1 = null;
        }
        let jsGeometry2: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometry2 = buildJsGeometry(geometry2) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometry2 = null;
        }
        return await this.component.touches(jsGeometry1,
            jsGeometry2);
    }

    async union(geometries: any): Promise<any> {
        let jsGeometries: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsGeometries = geometries.map(i => buildJsGeometry(i)) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsGeometries = null;
        }
        return await this.component.union(jsGeometries);
    }

    async within(innerGeometry: any,
        outerGeometry: any): Promise<any> {
        let jsInnerGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsInnerGeometry = buildJsGeometry(innerGeometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsInnerGeometry = null;
        }
        let jsOuterGeometry: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsGeometry } = await import('./geometry');
            // @ts-ignore GeoBlazor Pro only
            jsOuterGeometry = buildJsGeometry(outerGeometry) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsOuterGeometry = null;
        }
        return await this.component.within(jsInnerGeometry,
            jsOuterGeometry);
    }

    // region properties
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}


export async function buildJsGeometryEngineAsyncGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(dotNetObject)) {
        return null;
    }

    let jsgeometryEngineAsync: any = {};


    let { default: GeometryEngineAsyncWrapper } = await import('./geometryEngineAsync');
    let geometryEngineAsyncWrapper = new GeometryEngineAsyncWrapper(jsgeometryEngineAsync);
    geometryEngineAsyncWrapper.geoBlazorId = dotNetObject.id;
    geometryEngineAsyncWrapper.viewId = viewId;
    geometryEngineAsyncWrapper.layerId = layerId;
    
    let jsObjectRef = DotNet.createJSObjectReference(geometryEngineAsyncWrapper);
    jsObjectRefs[dotNetObject.id] = geometryEngineAsyncWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsgeometryEngineAsync;
    
    return jsgeometryEngineAsync;
}


export async function buildDotNetGeometryEngineAsyncGenerated(jsObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetGeometryEngineAsync: any = {};
    

    let geoBlazorId = lookupGeoBlazorId(jsObject);
    if (hasValue(geoBlazorId)) {
        dotNetGeometryEngineAsync.id = geoBlazorId;
    }

    return dotNetGeometryEngineAsync;
}

