// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import geometryEngineAsync = __esri.geometryEngineAsync;
import { arcGisObjectRefs, jsObjectRefs, hasValue } from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class GeometryEngineAsyncGenerated implements IPropertyWrapper {
    public component: geometryEngineAsync;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: geometryEngineAsync) {
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    
    async buffer(geometry: any,
        distance: any,
        unit: any,
        unionResults: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.buffer(jsGeometry,
            distance,
            unit,
            unionResults);
    }

    async clip(geometry: any,
        envelope: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        let { buildJsExtent } = await import('./extent');
        let jsEnvelope = buildJsExtent(envelope) as any;
        return await this.component.clip(jsGeometry,
            jsEnvelope);
    }

    async contains(containerGeometry: any,
        insideGeometry: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsContainerGeometry = buildJsGeometry(containerGeometry) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsInsideGeometry = buildJsGeometry(insideGeometry) as any;
        return await this.component.contains(jsContainerGeometry,
            jsInsideGeometry);
    }

    async convexHull(geometry: any,
        merge: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.convexHull(jsGeometry,
            merge);
    }

    async crosses(geometry1: any,
        geometry2: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry1 = buildJsGeometry(geometry1) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry2 = buildJsGeometry(geometry2) as any;
        return await this.component.crosses(jsGeometry1,
            jsGeometry2);
    }

    async cut(geometry: any,
        cutter: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        let { buildJsPolyline } = await import('./polyline');
        let jsCutter = buildJsPolyline(cutter) as any;
        return await this.component.cut(jsGeometry,
            jsCutter);
    }

    async densify(geometry: any,
        maxSegmentLength: any,
        maxSegmentLengthUnit: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.densify(jsGeometry,
            maxSegmentLength,
            maxSegmentLengthUnit);
    }

    async difference(inputGeometry: any,
        subtractor: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsInputGeometry = buildJsGeometry(inputGeometry) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsSubtractor = buildJsGeometry(subtractor) as any;
        return await this.component.difference(jsInputGeometry,
            jsSubtractor);
    }

    async disjoint(geometry1: any,
        geometry2: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry1 = buildJsGeometry(geometry1) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry2 = buildJsGeometry(geometry2) as any;
        return await this.component.disjoint(jsGeometry1,
            jsGeometry2);
    }

    async distance(geometry1: any,
        geometry2: any,
        distanceUnit: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry1 = buildJsGeometry(geometry1) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry2 = buildJsGeometry(geometry2) as any;
        return await this.component.distance(jsGeometry1,
            jsGeometry2,
            distanceUnit);
    }

    async extendedSpatialReferenceInfo(spatialReference: any): Promise<any> {
        let { buildJsSpatialReference } = await import('./spatialReference');
        let jsSpatialReference = buildJsSpatialReference(spatialReference) as any;
        return await this.component.extendedSpatialReferenceInfo(jsSpatialReference);
    }

    async flipHorizontal(geometry: any,
        flipOrigin: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        let { buildJsPoint } = await import('./point');
        let jsFlipOrigin = buildJsPoint(flipOrigin) as any;
        return await this.component.flipHorizontal(jsGeometry,
            jsFlipOrigin);
    }

    async flipVertical(geometry: any,
        flipOrigin: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        let { buildJsPoint } = await import('./point');
        let jsFlipOrigin = buildJsPoint(flipOrigin) as any;
        return await this.component.flipVertical(jsGeometry,
            jsFlipOrigin);
    }

    async generalize(geometry: any,
        maxDeviation: any,
        removeDegenerateParts: any,
        maxDeviationUnit: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.generalize(jsGeometry,
            maxDeviation,
            removeDegenerateParts,
            maxDeviationUnit);
    }

    async geodesicArea(geometry: any,
        unit: any): Promise<any> {
        let { buildJsPolygon } = await import('./polygon');
        let jsGeometry = buildJsPolygon(geometry) as any;
        return await this.component.geodesicArea(jsGeometry,
            unit);
    }

    async geodesicBuffer(geometry: any,
        distance: any,
        unit: any,
        unionResults: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.geodesicBuffer(jsGeometry,
            distance,
            unit,
            unionResults);
    }

    async geodesicDensify(geometry: any,
        maxSegmentLength: any,
        maxSegmentLengthUnit: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.geodesicDensify(jsGeometry,
            maxSegmentLength,
            maxSegmentLengthUnit);
    }

    async geodesicLength(geometry: any,
        unit: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.geodesicLength(jsGeometry,
            unit);
    }

    async intersect(geometry1: any,
        geometry2: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry1 = buildJsGeometry(geometry1) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry2 = buildJsGeometry(geometry2) as any;
        return await this.component.intersect(jsGeometry1,
            jsGeometry2);
    }

    async intersectLinesToPoints(line1: any,
        line2: any): Promise<any> {
        let { buildJsPolyline } = await import('./polyline');
        let jsLine1 = buildJsPolyline(line1) as any;
        let { buildJsPolyline } = await import('./polyline');
        let jsLine2 = buildJsPolyline(line2) as any;
        return await this.component.intersectLinesToPoints(jsLine1,
            jsLine2);
    }

    async intersects(geometry1: any,
        geometry2: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry1 = buildJsGeometry(geometry1) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry2 = buildJsGeometry(geometry2) as any;
        return await this.component.intersects(jsGeometry1,
            jsGeometry2);
    }

    async isSimple(geometry: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.isSimple(jsGeometry);
    }

    async nearestCoordinate(geometry: any,
        inputPoint: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        let { buildJsPoint } = await import('./point');
        let jsInputPoint = buildJsPoint(inputPoint) as any;
        return await this.component.nearestCoordinate(jsGeometry,
            jsInputPoint);
    }

    async nearestVertex(geometry: any,
        inputPoint: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        let { buildJsPoint } = await import('./point');
        let jsInputPoint = buildJsPoint(inputPoint) as any;
        return await this.component.nearestVertex(jsGeometry,
            jsInputPoint);
    }

    async nearestVertices(geometry: any,
        inputPoint: any,
        searchRadius: any,
        maxVertexCountToReturn: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        let { buildJsPoint } = await import('./point');
        let jsInputPoint = buildJsPoint(inputPoint) as any;
        return await this.component.nearestVertices(jsGeometry,
            jsInputPoint,
            searchRadius,
            maxVertexCountToReturn);
    }

    async offset(geometry: any,
        offsetDistance: any,
        offsetUnit: any,
        joinType: any,
        bevelRatio: any,
        flattenError: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.offset(jsGeometry,
            offsetDistance,
            offsetUnit,
            joinType,
            bevelRatio,
            flattenError);
    }

    async overlaps(geometry1: any,
        geometry2: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry1 = buildJsGeometry(geometry1) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry2 = buildJsGeometry(geometry2) as any;
        return await this.component.overlaps(jsGeometry1,
            jsGeometry2);
    }

    async planarArea(geometry: any,
        unit: any): Promise<any> {
        let { buildJsPolygon } = await import('./polygon');
        let jsGeometry = buildJsPolygon(geometry) as any;
        return await this.component.planarArea(jsGeometry,
            unit);
    }

    async planarLength(geometry: any,
        unit: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.planarLength(jsGeometry,
            unit);
    }

    async relate(geometry1: any,
        geometry2: any,
        relation: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry1 = buildJsGeometry(geometry1) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry2 = buildJsGeometry(geometry2) as any;
        return await this.component.relate(jsGeometry1,
            jsGeometry2,
            relation);
    }

    async rotate(geometry: any,
        angle: any,
        rotationOrigin: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        let { buildJsPoint } = await import('./point');
        let jsRotationOrigin = buildJsPoint(rotationOrigin) as any;
        return await this.component.rotate(jsGeometry,
            angle,
            jsRotationOrigin);
    }

    async simplify(geometry: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry = buildJsGeometry(geometry) as any;
        return await this.component.simplify(jsGeometry);
    }

    async symmetricDifference(leftGeometry: any,
        rightGeometry: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsLeftGeometry = buildJsGeometry(leftGeometry) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsRightGeometry = buildJsGeometry(rightGeometry) as any;
        return await this.component.symmetricDifference(jsLeftGeometry,
            jsRightGeometry);
    }

    async touches(geometry1: any,
        geometry2: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry1 = buildJsGeometry(geometry1) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometry2 = buildJsGeometry(geometry2) as any;
        return await this.component.touches(jsGeometry1,
            jsGeometry2);
    }

    async union(geometries: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsGeometries = buildJsGeometry(geometries) as any;
        return await this.component.union(jsGeometries);
    }

    async within(innerGeometry: any,
        outerGeometry: any): Promise<any> {
        let { buildJsGeometry } = await import('./geometry');
        let jsInnerGeometry = buildJsGeometry(innerGeometry) as any;
        let { buildJsGeometry } = await import('./geometry');
        let jsOuterGeometry = buildJsGeometry(outerGeometry) as any;
        return await this.component.within(jsInnerGeometry,
            jsOuterGeometry);
    }

    // region properties
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}


export async function buildJsGeometryEngineAsyncGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsgeometryEngineAsync: any = {};


    let { default: GeometryEngineAsyncWrapper } = await import('./geometryEngineAsync');
    let geometryEngineAsyncWrapper = new GeometryEngineAsyncWrapper(jsgeometryEngineAsync);
    geometryEngineAsyncWrapper.geoBlazorId = dotNetObject.id;
    geometryEngineAsyncWrapper.viewId = viewId;
    geometryEngineAsyncWrapper.layerId = layerId;
    
    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(geometryEngineAsyncWrapper);
    jsObjectRefs[dotNetObject.id] = geometryEngineAsyncWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsgeometryEngineAsync;
    let { buildDotNetGeometryEngineAsync } = await import('./geometryEngineAsync');
    let dnInstantiatedObject = await buildDotNetGeometryEngineAsync(jsgeometryEngineAsync);
    
    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for GeometryEngineAsync', e);
    }
    
    return jsgeometryEngineAsync;
}

export async function buildDotNetGeometryEngineAsyncGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetGeometryEngineAsync: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetGeometryEngineAsync.id = k;
                break;
            }
        }
    }

    return dotNetGeometryEngineAsync;
}

