// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file

import RouteLayerUpdateRouteLayerSolveResult = __esri.RouteLayerUpdateRouteLayerSolveResult;
import {arcGisObjectRefs, hasValue, jsObjectRefs} from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class RouteLayerUpdateRouteLayerSolveResultGenerated implements IPropertyWrapper {
    public component: RouteLayerUpdateRouteLayerSolveResult;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: RouteLayerUpdateRouteLayerSolveResult) {
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    
    // region properties
    
    async getDirectionLines(): Promise<any> {
        if (!hasValue(this.component.directionLines)) {
            return null;
        }
        
        let { buildDotNetDirectionLine } = await import('./directionLine');
        return await Promise.all(this.component.directionLines.map(async i => await buildDotNetDirectionLine(i)));
    }
    
    async setDirectionLines(value: any): Promise<void> {
        let { buildJsDirectionLine } = await import('./directionLine');
        this.component.directionLines = await Promise.all(value.map(async i => await buildJsDirectionLine(i, this.layerId, this.viewId))) as any;
    }
    
    async getDirectionPoints(): Promise<any> {
        if (!hasValue(this.component.directionPoints)) {
            return null;
        }
        
        let { buildDotNetDirectionPoint } = await import('./directionPoint');
        return await Promise.all(this.component.directionPoints.map(async i => await buildDotNetDirectionPoint(i)));
    }
    
    async setDirectionPoints(value: any): Promise<void> {
        let { buildJsDirectionPoint } = await import('./directionPoint');
        this.component.directionPoints = await Promise.all(value.map(async i => await buildJsDirectionPoint(i, this.layerId, this.viewId))) as any;
    }
    
    async getPolygonBarriers(): Promise<any> {
        if (!hasValue(this.component.polygonBarriers)) {
            return null;
        }
        
        let { buildDotNetPolygonBarrier } = await import('./polygonBarrier');
        return await Promise.all(this.component.polygonBarriers.map(async i => await buildDotNetPolygonBarrier(i)));
    }
    
    async setPolygonBarriers(value: any): Promise<void> {
        let { buildJsPolygonBarrier } = await import('./polygonBarrier');
        this.component.polygonBarriers = await Promise.all(value.map(async i => await buildJsPolygonBarrier(i, this.layerId, this.viewId))) as any;
    }
    
    async getPolylineBarriers(): Promise<any> {
        if (!hasValue(this.component.polylineBarriers)) {
            return null;
        }
        
        let { buildDotNetPolylineBarrier } = await import('./polylineBarrier');
        return await Promise.all(this.component.polylineBarriers.map(async i => await buildDotNetPolylineBarrier(i)));
    }
    
    async setPolylineBarriers(value: any): Promise<void> {
        let { buildJsPolylineBarrier } = await import('./polylineBarrier');
        this.component.polylineBarriers = await Promise.all(value.map(async i => await buildJsPolylineBarrier(i, this.layerId, this.viewId))) as any;
    }
    
    async getReadPointBarriers(): Promise<any> {
        if (!hasValue(this.component.readPointBarriers)) {
            return null;
        }
        
        let { buildDotNetPointBarrier } = await import('./pointBarrier');
        return await Promise.all(this.component.readPointBarriers.map(async i => await buildDotNetPointBarrier(i)));
    }
    
    async setReadPointBarriers(value: any): Promise<void> {
        let { buildJsPointBarrier } = await import('./pointBarrier');
        this.component.readPointBarriers = await Promise.all(value.map(async i => await buildJsPointBarrier(i, this.layerId, this.viewId))) as any;
    }
    
    async getRouteInfo(): Promise<any> {
        if (!hasValue(this.component.routeInfo)) {
            return null;
        }
        
        let { buildDotNetRouteInfo } = await import('./routeInfo');
        return await buildDotNetRouteInfo(this.component.routeInfo);
    }
    async setRouteInfo(value: any): Promise<void> {
        let { buildJsRouteInfo } = await import('./routeInfo');
        this.component.routeInfo = await  buildJsRouteInfo(value, this.layerId, this.viewId);
    }
    async getStops(): Promise<any> {
        if (!hasValue(this.component.stops)) {
            return null;
        }
        
        let { buildDotNetStop } = await import('./stop');
        return await Promise.all(this.component.stops.map(async i => await buildDotNetStop(i)));
    }
    
    async setStops(value: any): Promise<void> {
        let { buildJsStop } = await import('./stop');
        this.component.stops = await Promise.all(value.map(async i => await buildJsStop(i, this.layerId, this.viewId))) as any;
    }
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}

export async function buildJsRouteLayerUpdateRouteLayerSolveResultGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsRouteLayerUpdateRouteLayerSolveResult: any = {}
    if (hasValue(dotNetObject.directionLines)) {
        let { buildJsDirectionLine } = await import('./directionLine');
        jsRouteLayerUpdateRouteLayerSolveResult.directionLines = await Promise.all(dotNetObject.directionLines.map(async i => await buildJsDirectionLine(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.directionPoints)) {
        let { buildJsDirectionPoint } = await import('./directionPoint');
        jsRouteLayerUpdateRouteLayerSolveResult.directionPoints = await Promise.all(dotNetObject.directionPoints.map(async i => await buildJsDirectionPoint(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.polygonBarriers)) {
        let { buildJsPolygonBarrier } = await import('./polygonBarrier');
        jsRouteLayerUpdateRouteLayerSolveResult.polygonBarriers = await Promise.all(dotNetObject.polygonBarriers.map(async i => await buildJsPolygonBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.polylineBarriers)) {
        let { buildJsPolylineBarrier } = await import('./polylineBarrier');
        jsRouteLayerUpdateRouteLayerSolveResult.polylineBarriers = await Promise.all(dotNetObject.polylineBarriers.map(async i => await buildJsPolylineBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.readPointBarriers)) {
        let { buildJsPointBarrier } = await import('./pointBarrier');
        jsRouteLayerUpdateRouteLayerSolveResult.readPointBarriers = await Promise.all(dotNetObject.readPointBarriers.map(async i => await buildJsPointBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.routeInfo)) {
        let { buildJsRouteInfo } = await import('./routeInfo');
        jsRouteLayerUpdateRouteLayerSolveResult.routeInfo = await buildJsRouteInfo(dotNetObject.routeInfo, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.stops)) {
        let { buildJsStop } = await import('./stop');
        jsRouteLayerUpdateRouteLayerSolveResult.stops = await Promise.all(dotNetObject.stops.map(async i => await buildJsStop(i, layerId, viewId))) as any;
    }


    let { default: RouteLayerUpdateRouteLayerSolveResultWrapper } = await import('./routeLayerUpdateRouteLayerSolveResult');
    let routeLayerUpdateRouteLayerSolveResultWrapper = new RouteLayerUpdateRouteLayerSolveResultWrapper(jsRouteLayerUpdateRouteLayerSolveResult);
    routeLayerUpdateRouteLayerSolveResultWrapper.geoBlazorId = dotNetObject.id;
    routeLayerUpdateRouteLayerSolveResultWrapper.viewId = viewId;
    routeLayerUpdateRouteLayerSolveResultWrapper.layerId = layerId;
    
    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(routeLayerUpdateRouteLayerSolveResultWrapper);
    jsObjectRefs[dotNetObject.id] = routeLayerUpdateRouteLayerSolveResultWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsRouteLayerUpdateRouteLayerSolveResult;
    let { buildDotNetRouteLayerUpdateRouteLayerSolveResult } = await import('./routeLayerUpdateRouteLayerSolveResult');
    let dnInstantiatedObject = await buildDotNetRouteLayerUpdateRouteLayerSolveResult(jsRouteLayerUpdateRouteLayerSolveResult);
    
    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for RouteLayerUpdateRouteLayerSolveResult', e);
    }
    
    return jsRouteLayerUpdateRouteLayerSolveResult;
}
export async function buildDotNetRouteLayerUpdateRouteLayerSolveResultGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetRouteLayerUpdateRouteLayerSolveResult: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };
        if (hasValue(jsObject.directionLines)) {
            let { buildDotNetDirectionLine } = await import('./directionLine');
            dotNetRouteLayerUpdateRouteLayerSolveResult.directionLines = await Promise.all(jsObject.directionLines.map(async i => await buildDotNetDirectionLine(i)));
        }
        if (hasValue(jsObject.directionPoints)) {
            let { buildDotNetDirectionPoint } = await import('./directionPoint');
            dotNetRouteLayerUpdateRouteLayerSolveResult.directionPoints = await Promise.all(jsObject.directionPoints.map(async i => await buildDotNetDirectionPoint(i)));
        }
        if (hasValue(jsObject.polygonBarriers)) {
            let { buildDotNetPolygonBarrier } = await import('./polygonBarrier');
            dotNetRouteLayerUpdateRouteLayerSolveResult.polygonBarriers = await Promise.all(jsObject.polygonBarriers.map(async i => await buildDotNetPolygonBarrier(i)));
        }
        if (hasValue(jsObject.polylineBarriers)) {
            let { buildDotNetPolylineBarrier } = await import('./polylineBarrier');
            dotNetRouteLayerUpdateRouteLayerSolveResult.polylineBarriers = await Promise.all(jsObject.polylineBarriers.map(async i => await buildDotNetPolylineBarrier(i)));
        }
        if (hasValue(jsObject.readPointBarriers)) {
            let { buildDotNetPointBarrier } = await import('./pointBarrier');
            dotNetRouteLayerUpdateRouteLayerSolveResult.readPointBarriers = await Promise.all(jsObject.readPointBarriers.map(async i => await buildDotNetPointBarrier(i)));
        }
        if (hasValue(jsObject.routeInfo)) {
            let { buildDotNetRouteInfo } = await import('./routeInfo');
            dotNetRouteLayerUpdateRouteLayerSolveResult.routeInfo = await buildDotNetRouteInfo(jsObject.routeInfo);
        }
        if (hasValue(jsObject.stops)) {
            let { buildDotNetStop } = await import('./stop');
            dotNetRouteLayerUpdateRouteLayerSolveResult.stops = await Promise.all(jsObject.stops.map(async i => await buildDotNetStop(i)));
        }

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetRouteLayerUpdateRouteLayerSolveResult.id = k;
                break;
            }
        }
    }

    return dotNetRouteLayerUpdateRouteLayerSolveResult;
}

