// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import { arcGisObjectRefs, jsObjectRefs, hasValue } from './arcGisJsInterop';
import { buildDotNetRouteLayerUpdateRouteLayerSolveResult } from './routeLayerUpdateRouteLayerSolveResult';

export async function buildJsRouteLayerUpdateRouteLayerSolveResultGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsRouteLayerUpdateRouteLayerSolveResult: any = {}
    if (hasValue(dotNetObject.directionLines)) {
        let { buildJsDirectionLine } = await import('./directionLine');
        jsRouteLayerUpdateRouteLayerSolveResult.directionLines = await Promise.all(dotNetObject.directionLines.map(async i => await buildJsDirectionLine(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.directionPoints)) {
        let { buildJsDirectionPoint } = await import('./directionPoint');
        jsRouteLayerUpdateRouteLayerSolveResult.directionPoints = await Promise.all(dotNetObject.directionPoints.map(async i => await buildJsDirectionPoint(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.polygonBarriers)) {
        let { buildJsPolygonBarrier } = await import('./polygonBarrier');
        jsRouteLayerUpdateRouteLayerSolveResult.polygonBarriers = await Promise.all(dotNetObject.polygonBarriers.map(async i => await buildJsPolygonBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.polylineBarriers)) {
        let { buildJsPolylineBarrier } = await import('./polylineBarrier');
        jsRouteLayerUpdateRouteLayerSolveResult.polylineBarriers = await Promise.all(dotNetObject.polylineBarriers.map(async i => await buildJsPolylineBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.readPointBarriers)) {
        let { buildJsPointBarrier } = await import('./pointBarrier');
        jsRouteLayerUpdateRouteLayerSolveResult.readPointBarriers = await Promise.all(dotNetObject.readPointBarriers.map(async i => await buildJsPointBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.routeInfo)) {
        let { buildJsRouteInfo } = await import('./routeInfo');
        jsRouteLayerUpdateRouteLayerSolveResult.routeInfo = await buildJsRouteInfo(dotNetObject.routeInfo, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.stops)) {
        let { buildJsStop } = await import('./stop');
        jsRouteLayerUpdateRouteLayerSolveResult.stops = await Promise.all(dotNetObject.stops.map(async i => await buildJsStop(i, layerId, viewId))) as any;
    }

    
    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(jsRouteLayerUpdateRouteLayerSolveResult);
    jsObjectRefs[dotNetObject.id] = jsObjectRef;
    arcGisObjectRefs[dotNetObject.id] = jsRouteLayerUpdateRouteLayerSolveResult;
    
    let dnInstantiatedObject = await buildDotNetRouteLayerUpdateRouteLayerSolveResult(jsRouteLayerUpdateRouteLayerSolveResult);
    
    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for RouteLayerUpdateRouteLayerSolveResult', e);
    }
    
    return jsRouteLayerUpdateRouteLayerSolveResult;
}

export async function buildDotNetRouteLayerUpdateRouteLayerSolveResultGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetRouteLayerUpdateRouteLayerSolveResult: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };
        if (hasValue(jsObject.directionLines)) {
            let { buildDotNetDirectionLine } = await import('./directionLine');
            dotNetRouteLayerUpdateRouteLayerSolveResult.directionLines = await Promise.all(jsObject.directionLines.map(async i => await buildDotNetDirectionLine(i)));
        }
        if (hasValue(jsObject.directionPoints)) {
            let { buildDotNetDirectionPoint } = await import('./directionPoint');
            dotNetRouteLayerUpdateRouteLayerSolveResult.directionPoints = await Promise.all(jsObject.directionPoints.map(async i => await buildDotNetDirectionPoint(i)));
        }
        if (hasValue(jsObject.polygonBarriers)) {
            let { buildDotNetPolygonBarrier } = await import('./polygonBarrier');
            dotNetRouteLayerUpdateRouteLayerSolveResult.polygonBarriers = await Promise.all(jsObject.polygonBarriers.map(async i => await buildDotNetPolygonBarrier(i)));
        }
        if (hasValue(jsObject.polylineBarriers)) {
            let { buildDotNetPolylineBarrier } = await import('./polylineBarrier');
            dotNetRouteLayerUpdateRouteLayerSolveResult.polylineBarriers = await Promise.all(jsObject.polylineBarriers.map(async i => await buildDotNetPolylineBarrier(i)));
        }
        if (hasValue(jsObject.readPointBarriers)) {
            let { buildDotNetPointBarrier } = await import('./pointBarrier');
            dotNetRouteLayerUpdateRouteLayerSolveResult.readPointBarriers = await Promise.all(jsObject.readPointBarriers.map(async i => await buildDotNetPointBarrier(i)));
        }
        if (hasValue(jsObject.routeInfo)) {
            let { buildDotNetRouteInfo } = await import('./routeInfo');
            dotNetRouteLayerUpdateRouteLayerSolveResult.routeInfo = await buildDotNetRouteInfo(jsObject.routeInfo);
        }
        if (hasValue(jsObject.stops)) {
            let { buildDotNetStop } = await import('./stop');
            dotNetRouteLayerUpdateRouteLayerSolveResult.stops = await Promise.all(jsObject.stops.map(async i => await buildDotNetStop(i)));
        }

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetRouteLayerUpdateRouteLayerSolveResult.id = k;
                break;
            }
        }
    }

    return dotNetRouteLayerUpdateRouteLayerSolveResult;
}

