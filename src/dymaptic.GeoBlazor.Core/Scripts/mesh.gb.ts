// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import Mesh from '@arcgis/core/geometry/Mesh';
import { hasValue, Pro, generateSerializableJson } from './geoBlazorCore';
import BaseComponent from "./baseComponent";

export default class MeshGenerated extends BaseComponent {
    public component: Mesh;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: Mesh) {
        super(component);
        this.component = component;
    }
    

    async updateComponent(dotNetObject: any): Promise<void> {
        if (hasValue(dotNetObject.components) && dotNetObject.components.length > 0) {
            let { buildJsMeshComponent } = await import('./meshComponent');
            this.component.components = dotNetObject.components.map(i => buildJsMeshComponent(i)) as any;
        }
        if (hasValue(dotNetObject.spatialReference)) {
            let { buildJsSpatialReference } = await import('./spatialReference');
            this.component.spatialReference = buildJsSpatialReference(dotNetObject.spatialReference) as any;
        }
        if (hasValue(dotNetObject.transform)) {
            let { buildJsMeshTransform } = await import('./meshTransform');
            this.component.transform = buildJsMeshTransform(dotNetObject.transform) as any;
        }
        if (hasValue(dotNetObject.vertexAttributes)) {
            let { buildJsMeshVertexAttributes } = await import('./meshVertexAttributes');
            this.component.vertexAttributes = buildJsMeshVertexAttributes(dotNetObject.vertexAttributes) as any;
        }
        if (hasValue(dotNetObject.vertexSpace)) {
            this.component.vertexSpace = dotNetObject.iMeshVertexSpace;
        }

        if (hasValue(dotNetObject.hasM)) {
            this.component.hasM = dotNetObject.hasM;
        }
        if (hasValue(dotNetObject.hasZ)) {
            this.component.hasZ = dotNetObject.hasZ;
        }
    }
    
    // region methods
    async addComponent(component: any): Promise<void> {
        let { buildJsMeshComponent } = await import('./meshComponent');
        let jsComponent = buildJsMeshComponent(component) as any;
        this.component.addComponent(jsComponent);
    }

    async cancelLoad(): Promise<void> {
        this.component.cancelLoad();
    }

    async centerAt(location: any,
        parameters: any): Promise<any> {
        let { buildJsPoint } = await import('./point');
        let jsLocation = buildJsPoint(location) as any;
        let jsParameters: any;
        if (!Pro) {
            jsParameters = null;
        } else {
            try {
                // @ts-ignore GeoBlazor Pro only
                let { buildJsMeshCenterAtParameters } = await import('./meshCenterAtParameters');
                jsParameters = await buildJsMeshCenterAtParameters(parameters, this.layerId, this.viewId) as any;
            } catch (e) {
                console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
                jsParameters = null;
            }
        }
        let result = this.component.centerAt(jsLocation,
            jsParameters);
        let { buildDotNetMesh } = await import('./mesh');
        return buildDotNetMesh(result);
    }

    async isFulfilled(): Promise<any> {
        return this.component.isFulfilled();
    }

    async isRejected(): Promise<any> {
        return this.component.isRejected();
    }

    async isResolved(): Promise<any> {
        return this.component.isResolved();
    }

    async load(signal: AbortSignal): Promise<any> {
        let options = { signal: signal };
        let result = await this.component.load(options);
        let { buildDotNetMesh } = await import('./mesh');
        return buildDotNetMesh(result);
    }

    async offset(dx: any,
        dy: any,
        dz: any): Promise<any> {
        let result = this.component.offset(dx,
            dy,
            dz);
        let { buildDotNetMesh } = await import('./mesh');
        return buildDotNetMesh(result);
    }

    async removeComponent(component: any): Promise<void> {
        let { buildJsMeshComponent } = await import('./meshComponent');
        let jsComponent = buildJsMeshComponent(component) as any;
        this.component.removeComponent(jsComponent);
    }

    async rotate(angleX: any,
        angleY: any,
        angleZ: any,
        parameters: any): Promise<any> {
        let jsParameters: any;
        if (!Pro) {
            jsParameters = null;
        } else {
            try {
                // @ts-ignore GeoBlazor Pro only
                let { buildJsMeshRotateParameters } = await import('./meshRotateParameters');
                jsParameters = await buildJsMeshRotateParameters(parameters, this.layerId, this.viewId) as any;
            } catch (e) {
                console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
                jsParameters = null;
            }
        }
        let result = this.component.rotate(angleX,
            angleY,
            angleZ,
            jsParameters);
        let { buildDotNetMesh } = await import('./mesh');
        return buildDotNetMesh(result);
    }

    async scale(factor: any,
        parameters: any): Promise<any> {
        let jsParameters: any;
        if (!Pro) {
            jsParameters = null;
        } else {
            try {
                // @ts-ignore GeoBlazor Pro only
                let { buildJsMeshScaleParameters } = await import('./meshScaleParameters');
                jsParameters = await buildJsMeshScaleParameters(parameters, this.layerId, this.viewId) as any;
            } catch (e) {
                console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
                jsParameters = null;
            }
        }
        let result = this.component.scale(factor,
            jsParameters);
        let { buildDotNetMesh } = await import('./mesh');
        return buildDotNetMesh(result);
    }

    async toBinaryGLTF(options: any,
        signal: AbortSignal): Promise<any> {
        options.signal = signal;
        let jsOptions: any;
        if (!Pro) {
            jsOptions = null;
        } else {
            try {
                // @ts-ignore GeoBlazor Pro only
                let { buildJsMeshToBinaryGLTFOptions } = await import('./meshToBinaryGLTFOptions');
                jsOptions = await buildJsMeshToBinaryGLTFOptions(options, this.layerId, this.viewId) as any;
            } catch (e) {
                console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
                jsOptions = null;
            }
        }
        return await this.component.toBinaryGLTF(jsOptions);
    }

    async vertexAttributesChanged(): Promise<void> {
        this.component.vertexAttributesChanged();
    }

    async when(onFulfilled: any,
        onRejected: any): Promise<any> {
        return await this.component.when(onFulfilled,
            onRejected);
    }

    // region properties
    
    getCache(): any {
        if (!hasValue(this.component.cache)) {
            return null;
        }
        
        return generateSerializableJson(this.component.cache);
    }
    
    async getComponents(): Promise<any> {
        if (!hasValue(this.component.components)) {
            return null;
        }
        
        let { buildDotNetMeshComponent } = await import('./meshComponent');
        return this.component.components!.map(i => buildDotNetMeshComponent(i));
    }
    
    async setComponents(value: any): Promise<void> {
        if (!hasValue(value)) {
            this.component.components = [];
        }
        let { buildJsMeshComponent } = await import('./meshComponent');
        this.component.components = value.map(i => buildJsMeshComponent(i)) as any;
    }
    
    async getExtent(): Promise<any> {
        if (!hasValue(this.component.extent)) {
            return null;
        }
        
        let { buildDotNetExtent } = await import('./extent');
        return buildDotNetExtent(this.component.extent);
    }
    
    async getOrigin(): Promise<any> {
        if (!hasValue(this.component.origin)) {
            return null;
        }
        
        let { buildDotNetPoint } = await import('./point');
        return buildDotNetPoint(this.component.origin);
    }
    
    async getSpatialReference(): Promise<any> {
        if (!hasValue(this.component.spatialReference)) {
            return null;
        }
        
        let { buildDotNetSpatialReference } = await import('./spatialReference');
        return buildDotNetSpatialReference(this.component.spatialReference);
    }
    
    async setSpatialReference(value: any): Promise<void> {
        let { buildJsSpatialReference } = await import('./spatialReference');
        this.component.spatialReference =  buildJsSpatialReference(value);
    }
    
    async getTransform(): Promise<any> {
        if (!hasValue(this.component.transform)) {
            return null;
        }
        
        let { buildDotNetMeshTransform } = await import('./meshTransform');
        return buildDotNetMeshTransform(this.component.transform);
    }
    
    async setTransform(value: any): Promise<void> {
        let { buildJsMeshTransform } = await import('./meshTransform');
        this.component.transform =  buildJsMeshTransform(value);
    }
    
    async getVertexAttributes(): Promise<any> {
        if (!hasValue(this.component.vertexAttributes)) {
            return null;
        }
        
        let { buildDotNetMeshVertexAttributes } = await import('./meshVertexAttributes');
        return buildDotNetMeshVertexAttributes(this.component.vertexAttributes);
    }
    
    async setVertexAttributes(value: any): Promise<void> {
        let { buildJsMeshVertexAttributes } = await import('./meshVertexAttributes');
        this.component.vertexAttributes =  buildJsMeshVertexAttributes(value);
    }
    
}

