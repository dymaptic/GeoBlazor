// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import Slide from '@arcgis/core/webscene/Slide';
import { arcGisObjectRefs, jsObjectRefs, dotNetRefs, hasValue, lookupGeoBlazorId, removeCircularReferences, generateSerializableJson } from './geoBlazorCore';
import {IPropertyWrapper} from './definitions';

import BaseComponent from './baseComponent';

export default class SlideGenerated extends BaseComponent implements IPropertyWrapper {
    public component: Slide;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component:Slide) {
        super(component);
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    

    async updateComponent(dotNetObject: any): Promise<void> {
        if (hasValue(dotNetObject.basemap)) {
            let { buildJsBasemap } = await import('./basemap');
            this.component.basemap = await buildJsBasemap(dotNetObject.basemap, this.layerId, this.viewId) as any;
        }
        if (hasValue(dotNetObject.elements)) {
            let { buildJsSlideElements } = await import('./slideElements');
            this.component.elements = await buildJsSlideElements(dotNetObject.elements, this.layerId, this.viewId) as any;
        }
        if (hasValue(dotNetObject.timeExtent)) {
            let { buildJsTimeExtent } = await import('./timeExtent');
            this.component.timeExtent = buildJsTimeExtent(dotNetObject.timeExtent) as any;
        }
        if (hasValue(dotNetObject.viewpoint)) {
            let { buildJsViewpoint } = await import('./viewpoint');
            this.component.viewpoint = buildJsViewpoint(dotNetObject.viewpoint) as any;
        }

        if (hasValue(dotNetObject.description)) {
            this.component.description = dotNetObject.description;
        }
        if (hasValue(dotNetObject.enabledFocusAreas) && dotNetObject.enabledFocusAreas.length > 0) {
            this.component.enabledFocusAreas = dotNetObject.enabledFocusAreas;
        }
        if (hasValue(dotNetObject.environment)) {
            this.component.environment = dotNetObject.environment;
        }
        if (hasValue(dotNetObject.ground)) {
            this.component.ground = dotNetObject.ground;
        }
        if (hasValue(dotNetObject.hidden)) {
            this.component.hidden = dotNetObject.hidden;
        }
        if (hasValue(dotNetObject.layout)) {
            this.component.layout = dotNetObject.layout;
        }
        if (hasValue(dotNetObject.slideId)) {
            this.component.id = dotNetObject.slideId;
        }
        if (hasValue(dotNetObject.thumbnail)) {
            this.component.thumbnail = dotNetObject.thumbnail;
        }
        if (hasValue(dotNetObject.title)) {
            this.component.title = dotNetObject.title;
        }
        if (hasValue(dotNetObject.visibleLayers) && dotNetObject.visibleLayers.length > 0) {
            this.component.visibleLayers = dotNetObject.visibleLayers;
        }
    }
    
    async applyTo(view: any,
        options: any,
        signal: AbortSignal): Promise<any> {
        options.signal = signal;
        let result = await this.component.applyTo(view,
            options);
        let { buildDotNetSlide } = await import('./slide');
        return await buildDotNetSlide(result, this.layerId, this.viewId);
    }

    async updateFrom(view: any,
        options: any): Promise<any> {
        let result = await this.component.updateFrom(view,
            options);
        let { buildDotNetSlide } = await import('./slide');
        return await buildDotNetSlide(result, this.layerId, this.viewId);
    }

    // region properties
    
    async getBasemap(): Promise<any> {
        if (!hasValue(this.component.basemap)) {
            return null;
        }
        
        let { buildDotNetBasemap } = await import('./basemap');
        return await buildDotNetBasemap(this.component.basemap, this.viewId);
    }
    
    async setBasemap(value: any): Promise<void> {
        let { buildJsBasemap } = await import('./basemap');
        this.component.basemap = await  buildJsBasemap(value, this.layerId, this.viewId);
    }
    
    async getElements(): Promise<any> {
        if (!hasValue(this.component.elements)) {
            return null;
        }
        
        let { buildDotNetSlideElements } = await import('./slideElements');
        return await buildDotNetSlideElements(this.component.elements, this.layerId, this.viewId);
    }
    
    async setElements(value: any): Promise<void> {
        let { buildJsSlideElements } = await import('./slideElements');
        this.component.elements = await  buildJsSlideElements(value, this.layerId, this.viewId);
    }
    
    getSlideId(): any {
        if (!hasValue(this.component.id)) {
            return null;
        }
        
        return generateSerializableJson(this.component.id);
    }
    
    setSlideId(value: any): void {
        this.component.id = JSON.parse(value);
    }
    
    async getTimeExtent(): Promise<any> {
        if (!hasValue(this.component.timeExtent)) {
            return null;
        }
        
        let { buildDotNetTimeExtent } = await import('./timeExtent');
        return buildDotNetTimeExtent(this.component.timeExtent);
    }
    
    async setTimeExtent(value: any): Promise<void> {
        let { buildJsTimeExtent } = await import('./timeExtent');
        this.component.timeExtent =  buildJsTimeExtent(value);
    }
    
    async getViewpoint(): Promise<any> {
        if (!hasValue(this.component.viewpoint)) {
            return null;
        }
        
        let { buildDotNetViewpoint } = await import('./viewpoint');
        return buildDotNetViewpoint(this.component.viewpoint);
    }
    
    async setViewpoint(value: any): Promise<void> {
        let { buildJsViewpoint } = await import('./viewpoint');
        this.component.viewpoint =  buildJsViewpoint(value);
    }
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}


export async function buildJsSlideGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(dotNetObject)) {
        return null;
    }

    let properties: any = {};
    if (hasValue(dotNetObject.basemap)) {
        let { buildJsBasemap } = await import('./basemap');
        properties.basemap = await buildJsBasemap(dotNetObject.basemap, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.elements)) {
        let { buildJsSlideElements } = await import('./slideElements');
        properties.elements = await buildJsSlideElements(dotNetObject.elements, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.timeExtent)) {
        let { buildJsTimeExtent } = await import('./timeExtent');
        properties.timeExtent = buildJsTimeExtent(dotNetObject.timeExtent) as any;
    }
    if (hasValue(dotNetObject.viewpoint)) {
        let { buildJsViewpoint } = await import('./viewpoint');
        properties.viewpoint = buildJsViewpoint(dotNetObject.viewpoint) as any;
    }

    if (hasValue(dotNetObject.description)) {
        properties.description = dotNetObject.description;
    }
    if (hasValue(dotNetObject.enabledFocusAreas) && dotNetObject.enabledFocusAreas.length > 0) {
        properties.enabledFocusAreas = dotNetObject.enabledFocusAreas;
    }
    if (hasValue(dotNetObject.environment)) {
        properties.environment = dotNetObject.environment;
    }
    if (hasValue(dotNetObject.ground)) {
        properties.ground = dotNetObject.ground;
    }
    if (hasValue(dotNetObject.hidden)) {
        properties.hidden = dotNetObject.hidden;
    }
    if (hasValue(dotNetObject.layout)) {
        properties.layout = dotNetObject.layout;
    }
    if (hasValue(dotNetObject.slideId)) {
        properties.id = dotNetObject.slideId;
    }
    if (hasValue(dotNetObject.thumbnail)) {
        properties.thumbnail = dotNetObject.thumbnail;
    }
    if (hasValue(dotNetObject.title)) {
        properties.title = dotNetObject.title;
    }
    if (hasValue(dotNetObject.visibleLayers) && dotNetObject.visibleLayers.length > 0) {
        properties.visibleLayers = dotNetObject.visibleLayers;
    }
    let jsSlide = new Slide(properties);

    let { default: SlideWrapper } = await import('./slide');

    let slideWrapper = new SlideWrapper(jsSlide);
    slideWrapper.geoBlazorId = dotNetObject.id;
    slideWrapper.viewId = viewId;
    slideWrapper.layerId = layerId;
    
    jsObjectRefs[dotNetObject.id] = slideWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsSlide;
    
    return jsSlide;
}


export async function buildDotNetSlideGenerated(jsObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetSlide: any = {};
    
    if (hasValue(jsObject.basemap)) {
        let { buildDotNetBasemap } = await import('./basemap');
        dotNetSlide.basemap = await buildDotNetBasemap(jsObject.basemap, viewId);
    }
    
    if (hasValue(jsObject.elements)) {
        let { buildDotNetSlideElements } = await import('./slideElements');
        dotNetSlide.elements = await buildDotNetSlideElements(jsObject.elements, layerId, viewId);
    }
    
    if (hasValue(jsObject.timeExtent)) {
        let { buildDotNetTimeExtent } = await import('./timeExtent');
        dotNetSlide.timeExtent = buildDotNetTimeExtent(jsObject.timeExtent);
    }
    
    if (hasValue(jsObject.viewpoint)) {
        let { buildDotNetViewpoint } = await import('./viewpoint');
        dotNetSlide.viewpoint = buildDotNetViewpoint(jsObject.viewpoint);
    }
    
    if (hasValue(jsObject.description)) {
        dotNetSlide.description = removeCircularReferences(jsObject.description);
    }
    
    if (hasValue(jsObject.enabledFocusAreas)) {
        dotNetSlide.enabledFocusAreas = jsObject.enabledFocusAreas;
    }
    
    if (hasValue(jsObject.environment)) {
        dotNetSlide.environment = removeCircularReferences(jsObject.environment);
    }
    
    if (hasValue(jsObject.ground)) {
        dotNetSlide.ground = removeCircularReferences(jsObject.ground);
    }
    
    if (hasValue(jsObject.hidden)) {
        dotNetSlide.hidden = jsObject.hidden;
    }
    
    if (hasValue(jsObject.layout)) {
        dotNetSlide.layout = removeCircularReferences(jsObject.layout);
    }
    
    if (hasValue(jsObject.id)) {
        dotNetSlide.slideId = jsObject.id;
    }
    
    if (hasValue(jsObject.thumbnail)) {
        dotNetSlide.thumbnail = removeCircularReferences(jsObject.thumbnail);
    }
    
    if (hasValue(jsObject.title)) {
        dotNetSlide.title = removeCircularReferences(jsObject.title);
    }
    
    if (hasValue(jsObject.visibleLayers)) {
        dotNetSlide.visibleLayers = removeCircularReferences(jsObject.visibleLayers);
    }
    

    let geoBlazorId = lookupGeoBlazorId(jsObject);
    if (hasValue(geoBlazorId)) {
        dotNetSlide.id = geoBlazorId;
    } else if (hasValue(viewId)) {
        let dotNetRef = dotNetRefs[viewId!];
        if (hasValue(dotNetRef)) {
            try {
                dotNetSlide.id = await dotNetRef.invokeMethodAsync('GetId');
            } catch (e) {
                console.error('Error invoking GetId for Slide', e);
            }
        }
    }
    if (hasValue(dotNetSlide.id)) {
        jsObjectRefs[dotNetSlide.id] ??= jsObject;
        arcGisObjectRefs[dotNetSlide.id] ??= jsObject;
    }

    return dotNetSlide;
}

