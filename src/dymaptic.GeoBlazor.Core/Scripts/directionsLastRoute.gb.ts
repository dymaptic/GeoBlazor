// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import { buildDotNetDirectionsLastRoute } from './directionsLastRoute';
import DirectionsLastRoute = __esri.DirectionsLastRoute;
import {arcGisObjectRefs, hasValue, jsObjectRefs} from './arcGisJsInterop';

export async function buildJsDirectionsLastRouteGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsDirectionsLastRoute: any = {}
    if (hasValue(dotNetObject.directionLines)) {
        let { buildJsDirectionLine } = await import('./directionLine');
        jsDirectionsLastRoute.directionLines = await Promise.all(dotNetObject.directionLines.map(async i => await buildJsDirectionLine(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.directionPoints)) {
        let { buildJsDirectionPoint } = await import('./directionPoint');
        jsDirectionsLastRoute.directionPoints = await Promise.all(dotNetObject.directionPoints.map(async i => await buildJsDirectionPoint(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.pointBarriers)) {
        let { buildJsPointBarrier } = await import('./pointBarrier');
        jsDirectionsLastRoute.pointBarriers = await Promise.all(dotNetObject.pointBarriers.map(async i => await buildJsPointBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.polygonBarriers)) {
        let { buildJsPolygonBarrier } = await import('./polygonBarrier');
        jsDirectionsLastRoute.polygonBarriers = await Promise.all(dotNetObject.polygonBarriers.map(async i => await buildJsPolygonBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.polylineBarriers)) {
        let { buildJsPolylineBarrier } = await import('./polylineBarrier');
        jsDirectionsLastRoute.polylineBarriers = await Promise.all(dotNetObject.polylineBarriers.map(async i => await buildJsPolylineBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.routeInfo)) {
        let { buildJsRouteInfo } = await import('./routeInfo');
        jsDirectionsLastRoute.routeInfo = await buildJsRouteInfo(dotNetObject.routeInfo, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.stops)) {
        let { buildJsStop } = await import('./stop');
        jsDirectionsLastRoute.stops = await Promise.all(dotNetObject.stops.map(async i => await buildJsStop(i, layerId, viewId))) as any;
    }

    
    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(jsDirectionsLastRoute);
    jsObjectRefs[dotNetObject.id] = jsObjectRef;
    arcGisObjectRefs[dotNetObject.id] = jsDirectionsLastRoute;
    
    let dnInstantiatedObject = await buildDotNetDirectionsLastRoute(jsDirectionsLastRoute);
    
    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for DirectionsLastRoute', e);
    }
    
    return jsDirectionsLastRoute;
}

export async function buildDotNetDirectionsLastRouteGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetDirectionsLastRoute: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };
        if (hasValue(jsObject.directionLines)) {
            let { buildDotNetDirectionLine } = await import('./directionLine');
            dotNetDirectionsLastRoute.directionLines = await Promise.all(jsObject.directionLines.map(async i => await buildDotNetDirectionLine(i)));
        }
        if (hasValue(jsObject.directionPoints)) {
            let { buildDotNetDirectionPoint } = await import('./directionPoint');
            dotNetDirectionsLastRoute.directionPoints = await Promise.all(jsObject.directionPoints.map(async i => await buildDotNetDirectionPoint(i)));
        }
        if (hasValue(jsObject.pointBarriers)) {
            let { buildDotNetPointBarrier } = await import('./pointBarrier');
            dotNetDirectionsLastRoute.pointBarriers = await Promise.all(jsObject.pointBarriers.map(async i => await buildDotNetPointBarrier(i)));
        }
        if (hasValue(jsObject.polygonBarriers)) {
            let { buildDotNetPolygonBarrier } = await import('./polygonBarrier');
            dotNetDirectionsLastRoute.polygonBarriers = await Promise.all(jsObject.polygonBarriers.map(async i => await buildDotNetPolygonBarrier(i)));
        }
        if (hasValue(jsObject.polylineBarriers)) {
            let { buildDotNetPolylineBarrier } = await import('./polylineBarrier');
            dotNetDirectionsLastRoute.polylineBarriers = await Promise.all(jsObject.polylineBarriers.map(async i => await buildDotNetPolylineBarrier(i)));
        }
        if (hasValue(jsObject.routeInfo)) {
            let { buildDotNetRouteInfo } = await import('./routeInfo');
            dotNetDirectionsLastRoute.routeInfo = await buildDotNetRouteInfo(jsObject.routeInfo);
        }
        if (hasValue(jsObject.stops)) {
            let { buildDotNetStop } = await import('./stop');
            dotNetDirectionsLastRoute.stops = await Promise.all(jsObject.stops.map(async i => await buildDotNetStop(i)));
        }

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetDirectionsLastRoute.id = k;
                break;
            }
        }
    }

    return dotNetDirectionsLastRoute;
}

