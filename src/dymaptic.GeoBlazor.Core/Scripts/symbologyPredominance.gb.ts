// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import symbologyPredominance = __esri.symbologyPredominance;
import { arcGisObjectRefs, jsObjectRefs, hasValue } from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class SymbologyPredominanceGenerated implements IPropertyWrapper {
    public component: symbologyPredominance;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: symbologyPredominance) {
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    
    async cloneScheme(scheme: any): Promise<any> {
        let jsScheme: any; 
        try {
            // @ts-ignore GeoBlazor Pro only
            let { buildJsPredominanceSchemeForPolyline } = await import('./predominanceSchemeForPolyline');
            // @ts-ignore GeoBlazor Pro only
            jsScheme = await buildJsPredominanceSchemeForPolyline(scheme, this.layerId, this.viewId) as any;
        } catch (e) {
            console.error(`Pro functionality not available in GeoBlazor Core. ${e}`);
            jsScheme = null;
        }
        return this.component.cloneScheme(jsScheme);
    }

    async getSchemeByName(parameters: any): Promise<any> {
        return this.component.getSchemeByName(parameters);
    }

    async getSchemes(parameters: any): Promise<any> {
        return this.component.getSchemes(parameters);
    }

    async getSchemesByTag(parameters: any): Promise<any> {
        return this.component.getSchemesByTag(parameters);
    }

    async getThemes(basemap: any): Promise<any> {
        return this.component.getThemes(basemap);
    }

    // region properties
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}


export async function buildJsSymbologyPredominanceGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jssymbologyPredominance: any = {};


    let { default: SymbologyPredominanceWrapper } = await import('./symbologyPredominance');
    let symbologyPredominanceWrapper = new SymbologyPredominanceWrapper(jssymbologyPredominance);
    symbologyPredominanceWrapper.geoBlazorId = dotNetObject.id;
    symbologyPredominanceWrapper.viewId = viewId;
    symbologyPredominanceWrapper.layerId = layerId;
    
    let jsObjectRef = DotNet.createJSObjectReference(symbologyPredominanceWrapper);
    jsObjectRefs[dotNetObject.id] = symbologyPredominanceWrapper;
    arcGisObjectRefs[dotNetObject.id] = jssymbologyPredominance;
    
    return jssymbologyPredominance;
}


export async function buildDotNetSymbologyPredominanceGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetSymbologyPredominance: any = {
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };

    return dotNetSymbologyPredominance;
}

