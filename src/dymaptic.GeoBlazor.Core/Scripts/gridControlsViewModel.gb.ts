// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import GridControlsViewModel from '@arcgis/core/widgets/support/GridControls/GridControlsViewModel';
import { arcGisObjectRefs, jsObjectRefs, hasValue, lookupGeoBlazorId, removeCircularReferences } from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class GridControlsViewModelGenerated implements IPropertyWrapper {
    public component: GridControlsViewModel;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: GridControlsViewModel) {
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    

    async updateComponent(dotNetObject: any): Promise<void> {
        if (hasValue(dotNetObject.gridColor)) {
            let { buildJsMapColor } = await import('./mapColor');
            this.component.gridColor = buildJsMapColor(dotNetObject.gridColor) as any;
        }
        if (hasValue(dotNetObject.snappingOptions)) {
            let { buildJsSnappingOptions } = await import('./snappingOptions');
            this.component.snappingOptions = await buildJsSnappingOptions(dotNetObject.snappingOptions, this.layerId, this.viewId) as any;
        }

        if (hasValue(dotNetObject.dynamicScaling)) {
            this.component.dynamicScaling = dotNetObject.dynamicScaling;
        }
        if (hasValue(dotNetObject.interactivePlacementState)) {
            this.component.interactivePlacementState = dotNetObject.interactivePlacementState;
        }
        if (hasValue(dotNetObject.majorLineInterval)) {
            this.component.majorLineInterval = dotNetObject.majorLineInterval;
        }
        if (hasValue(dotNetObject.rotateWithMap)) {
            this.component.rotateWithMap = dotNetObject.rotateWithMap;
        }
        if (hasValue(dotNetObject.rotation)) {
            this.component.rotation = dotNetObject.rotation;
        }
        if (hasValue(dotNetObject.snappingEnabled)) {
            this.component.snappingEnabled = dotNetObject.snappingEnabled;
        }
        if (hasValue(dotNetObject.spacing)) {
            this.component.spacing = dotNetObject.spacing;
        }
        if (hasValue(dotNetObject.unit)) {
            this.component.unit = dotNetObject.unit;
        }
    }
    
    async trySetDisplayEnabled(visible: any): Promise<void> {
        this.component.trySetDisplayEnabled(visible);
    }

    // region properties
    
    async getGridColor(): Promise<any> {
        if (!hasValue(this.component.gridColor)) {
            return null;
        }
        
        let { buildDotNetMapColor } = await import('./mapColor');
        return buildDotNetMapColor(this.component.gridColor);
    }
    
    async setGridColor(value: any): Promise<void> {
        let { buildJsMapColor } = await import('./mapColor');
        this.component.gridColor =  buildJsMapColor(value);
    }
    
    async getSnappingOptions(): Promise<any> {
        if (!hasValue(this.component.snappingOptions)) {
            return null;
        }
        
        let { buildDotNetSnappingOptions } = await import('./snappingOptions');
        return await buildDotNetSnappingOptions(this.component.snappingOptions);
    }
    
    async setSnappingOptions(value: any): Promise<void> {
        let { buildJsSnappingOptions } = await import('./snappingOptions');
        this.component.snappingOptions = await  buildJsSnappingOptions(value, this.layerId, this.viewId);
    }
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}


export async function buildJsGridControlsViewModelGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(dotNetObject)) {
        return null;
    }

    let properties: any = {};
    if (hasValue(viewId)) {
        properties.view = arcGisObjectRefs[viewId!];
    }
    if (hasValue(dotNetObject.gridColor)) {
        let { buildJsMapColor } = await import('./mapColor');
        properties.gridColor = buildJsMapColor(dotNetObject.gridColor) as any;
    }
    if (hasValue(dotNetObject.snappingOptions)) {
        let { buildJsSnappingOptions } = await import('./snappingOptions');
        properties.snappingOptions = await buildJsSnappingOptions(dotNetObject.snappingOptions, layerId, viewId) as any;
    }

    if (hasValue(dotNetObject.dynamicScaling)) {
        properties.dynamicScaling = dotNetObject.dynamicScaling;
    }
    if (hasValue(dotNetObject.interactivePlacementState)) {
        properties.interactivePlacementState = dotNetObject.interactivePlacementState;
    }
    if (hasValue(dotNetObject.majorLineInterval)) {
        properties.majorLineInterval = dotNetObject.majorLineInterval;
    }
    if (hasValue(dotNetObject.rotateWithMap)) {
        properties.rotateWithMap = dotNetObject.rotateWithMap;
    }
    if (hasValue(dotNetObject.rotation)) {
        properties.rotation = dotNetObject.rotation;
    }
    if (hasValue(dotNetObject.snappingEnabled)) {
        properties.snappingEnabled = dotNetObject.snappingEnabled;
    }
    if (hasValue(dotNetObject.spacing)) {
        properties.spacing = dotNetObject.spacing;
    }
    if (hasValue(dotNetObject.unit)) {
        properties.unit = dotNetObject.unit;
    }
    let jsGridControlsViewModel = new GridControlsViewModel(properties);

    let { default: GridControlsViewModelWrapper } = await import('./gridControlsViewModel');
    let gridControlsViewModelWrapper = new GridControlsViewModelWrapper(jsGridControlsViewModel);
    gridControlsViewModelWrapper.geoBlazorId = dotNetObject.id;
    gridControlsViewModelWrapper.viewId = viewId;
    gridControlsViewModelWrapper.layerId = layerId;
    
    jsObjectRefs[dotNetObject.id] = gridControlsViewModelWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsGridControlsViewModel;
    
    return jsGridControlsViewModel;
}


export async function buildDotNetGridControlsViewModelGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetGridControlsViewModel: any = {};
    
    if (hasValue(jsObject.gridColor)) {
        let { buildDotNetMapColor } = await import('./mapColor');
        dotNetGridControlsViewModel.gridColor = buildDotNetMapColor(jsObject.gridColor);
    }
    
    if (hasValue(jsObject.snappingOptions)) {
        let { buildDotNetSnappingOptions } = await import('./snappingOptions');
        dotNetGridControlsViewModel.snappingOptions = await buildDotNetSnappingOptions(jsObject.snappingOptions);
    }
    
    if (hasValue(jsObject.displayEnabled)) {
        dotNetGridControlsViewModel.displayEnabled = jsObject.displayEnabled;
    }
    
    if (hasValue(jsObject.dynamicScaling)) {
        dotNetGridControlsViewModel.dynamicScaling = jsObject.dynamicScaling;
    }
    
    if (hasValue(jsObject.effectiveSpacingAfterDynamicScaling)) {
        dotNetGridControlsViewModel.effectiveSpacingAfterDynamicScaling = jsObject.effectiveSpacingAfterDynamicScaling;
    }
    
    if (hasValue(jsObject.gridControlsEnabled)) {
        dotNetGridControlsViewModel.gridControlsEnabled = jsObject.gridControlsEnabled;
    }
    
    if (hasValue(jsObject.gridOutOfScale)) {
        dotNetGridControlsViewModel.gridOutOfScale = jsObject.gridOutOfScale;
    }
    
    if (hasValue(jsObject.interactivePlacementState)) {
        dotNetGridControlsViewModel.interactivePlacementState = removeCircularReferences(jsObject.interactivePlacementState);
    }
    
    if (hasValue(jsObject.majorLineInterval)) {
        dotNetGridControlsViewModel.majorLineInterval = jsObject.majorLineInterval;
    }
    
    if (hasValue(jsObject.numericSpacingInputShouldBeVisible)) {
        dotNetGridControlsViewModel.numericSpacingInputShouldBeVisible = jsObject.numericSpacingInputShouldBeVisible;
    }
    
    if (hasValue(jsObject.rotateWithMap)) {
        dotNetGridControlsViewModel.rotateWithMap = jsObject.rotateWithMap;
    }
    
    if (hasValue(jsObject.rotation)) {
        dotNetGridControlsViewModel.rotation = jsObject.rotation;
    }
    
    if (hasValue(jsObject.snappingEnabled)) {
        dotNetGridControlsViewModel.snappingEnabled = jsObject.snappingEnabled;
    }
    
    if (hasValue(jsObject.spacing)) {
        dotNetGridControlsViewModel.spacing = jsObject.spacing;
    }
    
    if (hasValue(jsObject.unit)) {
        dotNetGridControlsViewModel.unit = removeCircularReferences(jsObject.unit);
    }
    

    let geoBlazorId = lookupGeoBlazorId(jsObject);
    if (hasValue(geoBlazorId)) {
        dotNetGridControlsViewModel.id = geoBlazorId;
    }

    return dotNetGridControlsViewModel;
}

