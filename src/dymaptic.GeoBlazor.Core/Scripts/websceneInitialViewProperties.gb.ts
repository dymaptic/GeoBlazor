// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import websceneInitialViewProperties from '@arcgis/core/webscene/InitialViewProperties';
import { arcGisObjectRefs, jsObjectRefs, hasValue, lookupGeoBlazorId, sanitize, removeCircularReferences } from './arcGisJsInterop';
import { buildDotNetWebsceneInitialViewProperties } from './websceneInitialViewProperties';

export async function buildJsWebsceneInitialViewPropertiesGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(dotNetObject)) {
        return null;
    }

    let properties: any = {};
    if (hasValue(dotNetObject.environment)) {
        let { buildJsEnvironment } = await import('./environment');
        properties.environment = await buildJsEnvironment(dotNetObject.environment, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.spatialReference)) {
        let { buildJsSpatialReference } = await import('./spatialReference');
        properties.spatialReference = buildJsSpatialReference(dotNetObject.spatialReference) as any;
    }
    if (hasValue(dotNetObject.timeExtent)) {
        let { buildJsTimeExtent } = await import('./timeExtent');
        properties.timeExtent = await buildJsTimeExtent(dotNetObject.timeExtent) as any;
    }
    if (hasValue(dotNetObject.viewpoint)) {
        let { buildJsViewpoint } = await import('./viewpoint');
        properties.viewpoint = buildJsViewpoint(dotNetObject.viewpoint) as any;
    }

    if (hasValue(dotNetObject.analyses) && dotNetObject.analyses.length > 0) {
        properties.analyses = sanitize(dotNetObject.analyses);
    }
    if (hasValue(dotNetObject.viewingMode)) {
        properties.viewingMode = dotNetObject.viewingMode;
    }
    let jswebsceneInitialViewProperties = new websceneInitialViewProperties(properties);
    
    jsObjectRefs[dotNetObject.id] = jswebsceneInitialViewProperties;
    arcGisObjectRefs[dotNetObject.id] = jswebsceneInitialViewProperties;
    
    return jswebsceneInitialViewProperties;
}


export async function buildDotNetWebsceneInitialViewPropertiesGenerated(jsObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetWebsceneInitialViewProperties: any = {};
    
    if (hasValue(jsObject.environment)) {
        let { buildDotNetEnvironment } = await import('./environment');
        dotNetWebsceneInitialViewProperties.environment = await buildDotNetEnvironment(jsObject.environment, layerId, viewId);
    }
    
    if (hasValue(jsObject.spatialReference)) {
        let { buildDotNetSpatialReference } = await import('./spatialReference');
        dotNetWebsceneInitialViewProperties.spatialReference = buildDotNetSpatialReference(jsObject.spatialReference);
    }
    
    if (hasValue(jsObject.timeExtent)) {
        let { buildDotNetTimeExtent } = await import('./timeExtent');
        dotNetWebsceneInitialViewProperties.timeExtent = buildDotNetTimeExtent(jsObject.timeExtent);
    }
    
    if (hasValue(jsObject.viewpoint)) {
        let { buildDotNetViewpoint } = await import('./viewpoint');
        dotNetWebsceneInitialViewProperties.viewpoint = buildDotNetViewpoint(jsObject.viewpoint);
    }
    
    if (hasValue(jsObject.analyses)) {
        dotNetWebsceneInitialViewProperties.analyses = removeCircularReferences(jsObject.analyses);
    }
    
    if (hasValue(jsObject.viewingMode)) {
        dotNetWebsceneInitialViewProperties.viewingMode = removeCircularReferences(jsObject.viewingMode);
    }
    

    let geoBlazorId = lookupGeoBlazorId(jsObject);
    if (hasValue(geoBlazorId)) {
        dotNetWebsceneInitialViewProperties.id = geoBlazorId;
    }

    return dotNetWebsceneInitialViewProperties;
}

