// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import { arcGisObjectRefs, jsObjectRefs, hasValue } from './arcGisJsInterop';
import { buildDotNetRouteLayerSolveResult } from './routeLayerSolveResult';

export async function buildJsRouteLayerSolveResultGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsRouteLayerSolveResult: any = {}
    if (hasValue(dotNetObject.directionLines)) {
        let { buildJsDirectionLine } = await import('./directionLine');
        jsRouteLayerSolveResult.directionLines = await Promise.all(dotNetObject.directionLines.map(async i => await buildJsDirectionLine(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.directionPoints)) {
        let { buildJsDirectionPoint } = await import('./directionPoint');
        jsRouteLayerSolveResult.directionPoints = await Promise.all(dotNetObject.directionPoints.map(async i => await buildJsDirectionPoint(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.pointBarriers)) {
        let { buildJsPointBarrier } = await import('./pointBarrier');
        jsRouteLayerSolveResult.pointBarriers = await Promise.all(dotNetObject.pointBarriers.map(async i => await buildJsPointBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.polygonBarriers)) {
        let { buildJsPolygonBarrier } = await import('./polygonBarrier');
        jsRouteLayerSolveResult.polygonBarriers = await Promise.all(dotNetObject.polygonBarriers.map(async i => await buildJsPolygonBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.polylineBarriers)) {
        let { buildJsPolylineBarrier } = await import('./polylineBarrier');
        jsRouteLayerSolveResult.polylineBarriers = await Promise.all(dotNetObject.polylineBarriers.map(async i => await buildJsPolylineBarrier(i, layerId, viewId))) as any;
    }
    if (hasValue(dotNetObject.routeInfo)) {
        let { buildJsRouteInfo } = await import('./routeInfo');
        jsRouteLayerSolveResult.routeInfo = await buildJsRouteInfo(dotNetObject.routeInfo, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.stops)) {
        let { buildJsStop } = await import('./stop');
        jsRouteLayerSolveResult.stops = await Promise.all(dotNetObject.stops.map(async i => await buildJsStop(i, layerId, viewId))) as any;
    }

    
    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(jsRouteLayerSolveResult);
    jsObjectRefs[dotNetObject.id] = jsObjectRef;
    arcGisObjectRefs[dotNetObject.id] = jsRouteLayerSolveResult;
    
    let dnInstantiatedObject = await buildDotNetRouteLayerSolveResult(jsRouteLayerSolveResult);
    
    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for RouteLayerSolveResult', e);
    }
    
    return jsRouteLayerSolveResult;
}

export async function buildDotNetRouteLayerSolveResultGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetRouteLayerSolveResult: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };
        if (hasValue(jsObject.directionLines)) {
            let { buildDotNetDirectionLine } = await import('./directionLine');
            dotNetRouteLayerSolveResult.directionLines = await Promise.all(jsObject.directionLines.map(async i => await buildDotNetDirectionLine(i)));
        }
        if (hasValue(jsObject.directionPoints)) {
            let { buildDotNetDirectionPoint } = await import('./directionPoint');
            dotNetRouteLayerSolveResult.directionPoints = await Promise.all(jsObject.directionPoints.map(async i => await buildDotNetDirectionPoint(i)));
        }
        if (hasValue(jsObject.pointBarriers)) {
            let { buildDotNetPointBarrier } = await import('./pointBarrier');
            dotNetRouteLayerSolveResult.pointBarriers = await Promise.all(jsObject.pointBarriers.map(async i => await buildDotNetPointBarrier(i)));
        }
        if (hasValue(jsObject.polygonBarriers)) {
            let { buildDotNetPolygonBarrier } = await import('./polygonBarrier');
            dotNetRouteLayerSolveResult.polygonBarriers = await Promise.all(jsObject.polygonBarriers.map(async i => await buildDotNetPolygonBarrier(i)));
        }
        if (hasValue(jsObject.polylineBarriers)) {
            let { buildDotNetPolylineBarrier } = await import('./polylineBarrier');
            dotNetRouteLayerSolveResult.polylineBarriers = await Promise.all(jsObject.polylineBarriers.map(async i => await buildDotNetPolylineBarrier(i)));
        }
        if (hasValue(jsObject.routeInfo)) {
            let { buildDotNetRouteInfo } = await import('./routeInfo');
            dotNetRouteLayerSolveResult.routeInfo = await buildDotNetRouteInfo(jsObject.routeInfo);
        }
        if (hasValue(jsObject.stops)) {
            let { buildDotNetStop } = await import('./stop');
            dotNetRouteLayerSolveResult.stops = await Promise.all(jsObject.stops.map(async i => await buildDotNetStop(i)));
        }

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetRouteLayerSolveResult.id = k;
                break;
            }
        }
    }

    return dotNetRouteLayerSolveResult;
}

