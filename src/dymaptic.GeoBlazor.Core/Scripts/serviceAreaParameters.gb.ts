// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file

import ServiceAreaParameters from '@arcgis/core/rest/support/ServiceAreaParameters';
import {arcGisObjectRefs, hasValue, jsObjectRefs} from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class ServiceAreaParametersGenerated implements IPropertyWrapper {
    public component: ServiceAreaParameters;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: ServiceAreaParameters) {
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    
    // region properties
    
    async getPointBarriers(): Promise<any> {
        if (!hasValue(this.component.pointBarriers)) {
            return null;
        }
        
        let { buildDotNetPointBarrier } = await import('./pointBarrier');
        return await Promise.all(this.component.pointBarriers.map(async i => await buildDotNetPointBarrier(i)));
    }
    
    async setPointBarriers(value: any): Promise<void> {
        let { buildJsPointBarrier } = await import('./pointBarrier');
        this.component.pointBarriers = await Promise.all(value.map(async i => await buildJsPointBarrier(i, this.layerId, this.viewId))) as any;
    }
    
    async getPolygonBarriers(): Promise<any> {
        if (!hasValue(this.component.polygonBarriers)) {
            return null;
        }
        
        let { buildDotNetPolygonBarrier } = await import('./polygonBarrier');
        return await Promise.all(this.component.polygonBarriers.map(async i => await buildDotNetPolygonBarrier(i)));
    }
    
    async setPolygonBarriers(value: any): Promise<void> {
        let { buildJsPolygonBarrier } = await import('./polygonBarrier');
        this.component.polygonBarriers = await Promise.all(value.map(async i => await buildJsPolygonBarrier(i, this.layerId, this.viewId))) as any;
    }
    
    async getPolylineBarriers(): Promise<any> {
        if (!hasValue(this.component.polylineBarriers)) {
            return null;
        }
        
        let { buildDotNetPolylineBarrier } = await import('./polylineBarrier');
        return await Promise.all(this.component.polylineBarriers.map(async i => await buildDotNetPolylineBarrier(i)));
    }
    
    async setPolylineBarriers(value: any): Promise<void> {
        let { buildJsPolylineBarrier } = await import('./polylineBarrier');
        this.component.polylineBarriers = await Promise.all(value.map(async i => await buildJsPolylineBarrier(i, this.layerId, this.viewId))) as any;
    }
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}

export async function buildJsServiceAreaParametersGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jsServiceAreaParameters = new ServiceAreaParameters();
    if (hasValue(dotNetObject.accumulateAttributesCollectionAccumulateAttributes)) {
        jsServiceAreaParameters.accumulateAttributes = dotNetObject.accumulateAttributes;
    }
    if (hasValue(dotNetObject.attributeParameterValues)) {
        jsServiceAreaParameters.attributeParameterValues = dotNetObject.serviceAreaParametersAttributeParameterValue;
    }
    if (hasValue(dotNetObject.facilities)) {
        jsServiceAreaParameters.facilities = dotNetObject.iServiceAreaParametersFacilities;
    }
    if (hasValue(dotNetObject.impedanceAttribute)) {
        jsServiceAreaParameters.impedanceAttribute = dotNetObject.impedanceAttribute;
    }
    if (hasValue(dotNetObject.outputGeometryPrecisionUnits)) {
        jsServiceAreaParameters.outputGeometryPrecisionUnits = dotNetObject.outputGeometryPrecisionUnits;
    }
    if (hasValue(dotNetObject.outputLines)) {
        jsServiceAreaParameters.outputLines = dotNetObject.outputLines;
    }
    if (hasValue(dotNetObject.outputPolygons)) {
        jsServiceAreaParameters.outputPolygons = dotNetObject.outputPolygons;
    }
    if (hasValue(dotNetObject.outSpatialReference)) {
        let { buildJsSpatialReference } = await import('./spatialReference');
        jsServiceAreaParameters.outSpatialReference = buildJsSpatialReference(dotNetObject.outSpatialReference) as any;
    }
    if (hasValue(dotNetObject.pointBarrierCollectionPointBarriers)) {
        let { buildJsPointBarrier } = await import('./pointBarrier');
        jsServiceAreaParameters.pointBarriers = await Promise.all(dotNetObject.pointBarrierCollectionPointBarriers.map(async i => await buildJsPointBarrier(i, layerId, viewId))) as any;
    }
    else if (hasValue(dotNetObject.dataLayerPointBarriers)) {
        let { buildJsDataLayer } = await import('./pointBarrier');
        jsServiceAreaParameters.pointBarriers = await Promise.all(dotNetObject.dataLayerPointBarriers.map(async i => await buildJsDataLayer(i, layerId, viewId))) as any;
    }
    else if (hasValue(dotNetObject.featureSetPointBarriers)) {
        let { buildJsFeatureSet } = await import('./pointBarrier');
        jsServiceAreaParameters.pointBarriers = dotNetObject.featureSetPointBarriers.map(i => buildJsFeatureSet(i)) as any;
    }
    else if (hasValue(dotNetObject.networkFeatureSetPointBarriers)) {
        jsServiceAreaParameters.pointBarriers = dotNetObject.pointBarrier;
    }
    if (hasValue(dotNetObject.polygonBarrierCollectionPolygonBarriers)) {
        let { buildJsPolygonBarrier } = await import('./polygonBarrier');
        jsServiceAreaParameters.polygonBarriers = await Promise.all(dotNetObject.polygonBarrierCollectionPolygonBarriers.map(async i => await buildJsPolygonBarrier(i, layerId, viewId))) as any;
    }
    else if (hasValue(dotNetObject.dataLayerPolygonBarriers)) {
        let { buildJsDataLayer } = await import('./polygonBarrier');
        jsServiceAreaParameters.polygonBarriers = await Promise.all(dotNetObject.dataLayerPolygonBarriers.map(async i => await buildJsDataLayer(i, layerId, viewId))) as any;
    }
    else if (hasValue(dotNetObject.featureSetPolygonBarriers)) {
        let { buildJsFeatureSet } = await import('./polygonBarrier');
        jsServiceAreaParameters.polygonBarriers = dotNetObject.featureSetPolygonBarriers.map(i => buildJsFeatureSet(i)) as any;
    }
    else if (hasValue(dotNetObject.networkFeatureSetPolygonBarriers)) {
        jsServiceAreaParameters.polygonBarriers = dotNetObject.polygonBarrier;
    }
    if (hasValue(dotNetObject.polylineBarrierCollectionPolylineBarriers)) {
        let { buildJsPolylineBarrier } = await import('./polylineBarrier');
        jsServiceAreaParameters.polylineBarriers = await Promise.all(dotNetObject.polylineBarrierCollectionPolylineBarriers.map(async i => await buildJsPolylineBarrier(i, layerId, viewId))) as any;
    }
    else if (hasValue(dotNetObject.dataLayerPolylineBarriers)) {
        let { buildJsDataLayer } = await import('./polylineBarrier');
        jsServiceAreaParameters.polylineBarriers = await Promise.all(dotNetObject.dataLayerPolylineBarriers.map(async i => await buildJsDataLayer(i, layerId, viewId))) as any;
    }
    else if (hasValue(dotNetObject.featureSetPolylineBarriers)) {
        let { buildJsFeatureSet } = await import('./polylineBarrier');
        jsServiceAreaParameters.polylineBarriers = dotNetObject.featureSetPolylineBarriers.map(i => buildJsFeatureSet(i)) as any;
    }
    else if (hasValue(dotNetObject.networkFeatureSetPolylineBarriers)) {
        jsServiceAreaParameters.polylineBarriers = dotNetObject.polylineBarrier;
    }
    if (hasValue(dotNetObject.restrictionAttributesCollectionRestrictionAttributes)) {
        jsServiceAreaParameters.restrictionAttributes = dotNetObject.restrictionAttributes;
    }
    if (hasValue(dotNetObject.restrictUTurns)) {
        jsServiceAreaParameters.restrictUTurns = dotNetObject.restrictUTurns;
    }
    if (hasValue(dotNetObject.travelDirection)) {
        jsServiceAreaParameters.travelDirection = dotNetObject.travelDirection;
    }
    if (hasValue(dotNetObject.travelMode)) {
        jsServiceAreaParameters.travelMode = dotNetObject.travelMode;
    }
    if (hasValue(dotNetObject.trimPolygonDistanceUnits)) {
        jsServiceAreaParameters.trimPolygonDistanceUnits = dotNetObject.trimPolygonDistanceUnits;
    }

    if (hasValue(dotNetObject.apiKey)) {
        jsServiceAreaParameters.apiKey = dotNetObject.apiKey;
    }
    if (hasValue(dotNetObject.defaultBreaks)) {
        jsServiceAreaParameters.defaultBreaks = dotNetObject.defaultBreaks;
    }
    if (hasValue(dotNetObject.excludeSourcesFromPolygons)) {
        jsServiceAreaParameters.excludeSourcesFromPolygons = dotNetObject.excludeSourcesFromPolygons;
    }
    if (hasValue(dotNetObject.geometryPrecision)) {
        jsServiceAreaParameters.geometryPrecision = dotNetObject.geometryPrecision;
    }
    if (hasValue(dotNetObject.geometryPrecisionM)) {
        jsServiceAreaParameters.geometryPrecisionM = dotNetObject.geometryPrecisionM;
    }
    if (hasValue(dotNetObject.geometryPrecisionZ)) {
        jsServiceAreaParameters.geometryPrecisionZ = dotNetObject.geometryPrecisionZ;
    }
    if (hasValue(dotNetObject.ignoreInvalidLocations)) {
        jsServiceAreaParameters.ignoreInvalidLocations = dotNetObject.ignoreInvalidLocations;
    }
    if (hasValue(dotNetObject.mergeSimilarPolygonRanges)) {
        jsServiceAreaParameters.mergeSimilarPolygonRanges = dotNetObject.mergeSimilarPolygonRanges;
    }
    if (hasValue(dotNetObject.outputGeometryPrecision)) {
        jsServiceAreaParameters.outputGeometryPrecision = dotNetObject.outputGeometryPrecision;
    }
    if (hasValue(dotNetObject.overlapLines)) {
        jsServiceAreaParameters.overlapLines = dotNetObject.overlapLines;
    }
    if (hasValue(dotNetObject.overlapPolygons)) {
        jsServiceAreaParameters.overlapPolygons = dotNetObject.overlapPolygons;
    }
    if (hasValue(dotNetObject.overrides)) {
        jsServiceAreaParameters.overrides = dotNetObject.overrides;
    }
    if (hasValue(dotNetObject.preserveObjectID)) {
        jsServiceAreaParameters.preserveObjectID = dotNetObject.preserveObjectID;
    }
    if (hasValue(dotNetObject.returnFacilities)) {
        jsServiceAreaParameters.returnFacilities = dotNetObject.returnFacilities;
    }
    if (hasValue(dotNetObject.returnPointBarriers)) {
        jsServiceAreaParameters.returnPointBarriers = dotNetObject.returnPointBarriers;
    }
    if (hasValue(dotNetObject.returnPolygonBarriers)) {
        jsServiceAreaParameters.returnPolygonBarriers = dotNetObject.returnPolygonBarriers;
    }
    if (hasValue(dotNetObject.returnPolylineBarriers)) {
        jsServiceAreaParameters.returnPolylineBarriers = dotNetObject.returnPolylineBarriers;
    }
    if (hasValue(dotNetObject.splitLinesAtBreaks)) {
        jsServiceAreaParameters.splitLinesAtBreaks = dotNetObject.splitLinesAtBreaks;
    }
    if (hasValue(dotNetObject.splitPolygonsAtBreaks)) {
        jsServiceAreaParameters.splitPolygonsAtBreaks = dotNetObject.splitPolygonsAtBreaks;
    }
    if (hasValue(dotNetObject.timeOfDay)) {
        jsServiceAreaParameters.timeOfDay = dotNetObject.timeOfDay;
    }
    if (hasValue(dotNetObject.timeOfDayIsUTC)) {
        jsServiceAreaParameters.timeOfDayIsUTC = dotNetObject.timeOfDayIsUTC;
    }
    if (hasValue(dotNetObject.trimOuterPolygon)) {
        jsServiceAreaParameters.trimOuterPolygon = dotNetObject.trimOuterPolygon;
    }
    if (hasValue(dotNetObject.trimPolygonDistance)) {
        jsServiceAreaParameters.trimPolygonDistance = dotNetObject.trimPolygonDistance;
    }
    if (hasValue(dotNetObject.useHierarchy)) {
        jsServiceAreaParameters.useHierarchy = dotNetObject.useHierarchy;
    }

    let { default: ServiceAreaParametersWrapper } = await import('./serviceAreaParameters');
    let serviceAreaParametersWrapper = new ServiceAreaParametersWrapper(jsServiceAreaParameters);
    serviceAreaParametersWrapper.geoBlazorId = dotNetObject.id;
    serviceAreaParametersWrapper.viewId = viewId;
    serviceAreaParametersWrapper.layerId = layerId;
    
    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(serviceAreaParametersWrapper);
    jsObjectRefs[dotNetObject.id] = serviceAreaParametersWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsServiceAreaParameters;
    let { buildDotNetServiceAreaParameters } = await import('./serviceAreaParameters');
    let dnInstantiatedObject = await buildDotNetServiceAreaParameters(jsServiceAreaParameters);
    
    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for ServiceAreaParameters', e);
    }
    
    return jsServiceAreaParameters;
}
export async function buildDotNetServiceAreaParametersGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetServiceAreaParameters: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };
        dotNetServiceAreaParameters.accumulateAttributes = jsObject.accumulateAttributes;
        dotNetServiceAreaParameters.attributeParameterValues = jsObject.attributeParameterValues;
        dotNetServiceAreaParameters.facilities = jsObject.facilities;
        dotNetServiceAreaParameters.impedanceAttribute = jsObject.impedanceAttribute;
        dotNetServiceAreaParameters.outputGeometryPrecisionUnits = jsObject.outputGeometryPrecisionUnits;
        dotNetServiceAreaParameters.outputLines = jsObject.outputLines;
        dotNetServiceAreaParameters.outputPolygons = jsObject.outputPolygons;
        if (hasValue(jsObject.outSpatialReference)) {
            let { buildDotNetSpatialReference } = await import('./spatialReference');
            dotNetServiceAreaParameters.outSpatialReference = buildDotNetSpatialReference(jsObject.outSpatialReference);
        }
        if (hasValue(jsObject.pointBarriers)) {
            let { buildDotNetPointBarrier } = await import('./pointBarrier');
            dotNetServiceAreaParameters.pointBarriers = await Promise.all(jsObject.pointBarriers.map(async i => await buildDotNetPointBarrier(i)));
        }
        if (hasValue(jsObject.polygonBarriers)) {
            let { buildDotNetPolygonBarrier } = await import('./polygonBarrier');
            dotNetServiceAreaParameters.polygonBarriers = await Promise.all(jsObject.polygonBarriers.map(async i => await buildDotNetPolygonBarrier(i)));
        }
        if (hasValue(jsObject.polylineBarriers)) {
            let { buildDotNetPolylineBarrier } = await import('./polylineBarrier');
            dotNetServiceAreaParameters.polylineBarriers = await Promise.all(jsObject.polylineBarriers.map(async i => await buildDotNetPolylineBarrier(i)));
        }
        dotNetServiceAreaParameters.restrictionAttributes = jsObject.restrictionAttributes;
        dotNetServiceAreaParameters.restrictUTurns = jsObject.restrictUTurns;
        dotNetServiceAreaParameters.travelDirection = jsObject.travelDirection;
        dotNetServiceAreaParameters.travelMode = jsObject.travelMode;
        dotNetServiceAreaParameters.trimPolygonDistanceUnits = jsObject.trimPolygonDistanceUnits;
        if (hasValue(jsObject.apiKey)) {
            dotNetServiceAreaParameters.apiKey = jsObject.apiKey;
        }
        if (hasValue(jsObject.defaultBreaks)) {
            dotNetServiceAreaParameters.defaultBreaks = jsObject.defaultBreaks;
        }
        if (hasValue(jsObject.excludeSourcesFromPolygons)) {
            dotNetServiceAreaParameters.excludeSourcesFromPolygons = jsObject.excludeSourcesFromPolygons;
        }
        if (hasValue(jsObject.geometryPrecision)) {
            dotNetServiceAreaParameters.geometryPrecision = jsObject.geometryPrecision;
        }
        if (hasValue(jsObject.geometryPrecisionM)) {
            dotNetServiceAreaParameters.geometryPrecisionM = jsObject.geometryPrecisionM;
        }
        if (hasValue(jsObject.geometryPrecisionZ)) {
            dotNetServiceAreaParameters.geometryPrecisionZ = jsObject.geometryPrecisionZ;
        }
        if (hasValue(jsObject.ignoreInvalidLocations)) {
            dotNetServiceAreaParameters.ignoreInvalidLocations = jsObject.ignoreInvalidLocations;
        }
        if (hasValue(jsObject.mergeSimilarPolygonRanges)) {
            dotNetServiceAreaParameters.mergeSimilarPolygonRanges = jsObject.mergeSimilarPolygonRanges;
        }
        if (hasValue(jsObject.outputGeometryPrecision)) {
            dotNetServiceAreaParameters.outputGeometryPrecision = jsObject.outputGeometryPrecision;
        }
        if (hasValue(jsObject.overlapLines)) {
            dotNetServiceAreaParameters.overlapLines = jsObject.overlapLines;
        }
        if (hasValue(jsObject.overlapPolygons)) {
            dotNetServiceAreaParameters.overlapPolygons = jsObject.overlapPolygons;
        }
        if (hasValue(jsObject.overrides)) {
            dotNetServiceAreaParameters.overrides = jsObject.overrides;
        }
        if (hasValue(jsObject.preserveObjectID)) {
            dotNetServiceAreaParameters.preserveObjectID = jsObject.preserveObjectID;
        }
        if (hasValue(jsObject.returnFacilities)) {
            dotNetServiceAreaParameters.returnFacilities = jsObject.returnFacilities;
        }
        if (hasValue(jsObject.returnPointBarriers)) {
            dotNetServiceAreaParameters.returnPointBarriers = jsObject.returnPointBarriers;
        }
        if (hasValue(jsObject.returnPolygonBarriers)) {
            dotNetServiceAreaParameters.returnPolygonBarriers = jsObject.returnPolygonBarriers;
        }
        if (hasValue(jsObject.returnPolylineBarriers)) {
            dotNetServiceAreaParameters.returnPolylineBarriers = jsObject.returnPolylineBarriers;
        }
        if (hasValue(jsObject.splitLinesAtBreaks)) {
            dotNetServiceAreaParameters.splitLinesAtBreaks = jsObject.splitLinesAtBreaks;
        }
        if (hasValue(jsObject.splitPolygonsAtBreaks)) {
            dotNetServiceAreaParameters.splitPolygonsAtBreaks = jsObject.splitPolygonsAtBreaks;
        }
        if (hasValue(jsObject.timeOfDay)) {
            dotNetServiceAreaParameters.timeOfDay = jsObject.timeOfDay;
        }
        if (hasValue(jsObject.timeOfDayIsUTC)) {
            dotNetServiceAreaParameters.timeOfDayIsUTC = jsObject.timeOfDayIsUTC;
        }
        if (hasValue(jsObject.trimOuterPolygon)) {
            dotNetServiceAreaParameters.trimOuterPolygon = jsObject.trimOuterPolygon;
        }
        if (hasValue(jsObject.trimPolygonDistance)) {
            dotNetServiceAreaParameters.trimPolygonDistance = jsObject.trimPolygonDistance;
        }
        if (hasValue(jsObject.useHierarchy)) {
            dotNetServiceAreaParameters.useHierarchy = jsObject.useHierarchy;
        }

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetServiceAreaParameters.id = k;
                break;
            }
        }
    }

    return dotNetServiceAreaParameters;
}

