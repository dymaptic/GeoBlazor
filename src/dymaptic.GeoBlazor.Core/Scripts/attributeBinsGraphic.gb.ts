// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file.
import AttributeBinsGraphic from '@arcgis/core/AttributeBinsGraphic';
import { arcGisObjectRefs, jsObjectRefs, hasValue, lookupGeoBlazorId, removeCircularReferences, generateSerializableJson } from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class AttributeBinsGraphicGenerated implements IPropertyWrapper {
    public component: AttributeBinsGraphic;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: AttributeBinsGraphic) {
        this.component = component;
    }
    
    // region methods
   
    unwrap() {
        return this.component;
    }
    

    async updateComponent(dotNetObject: any): Promise<void> {
        if (hasValue(dotNetObject.geometry)) {
            let { buildJsGeometry } = await import('./geometry');
            this.component.geometry = buildJsGeometry(dotNetObject.geometry) as any;
        }
        if (hasValue(dotNetObject.layer)) {
            let { buildJsLayer } = await import('./layer');
            this.component.layer = await buildJsLayer(dotNetObject.layer, this.layerId, this.viewId) as any;
        }
        if (hasValue(dotNetObject.popupTemplate)) {
            let { buildJsPopupTemplate } = await import('./popupTemplate');
            this.component.popupTemplate = buildJsPopupTemplate(dotNetObject.popupTemplate, this.layerId, this.viewId) as any;
        }
        if (hasValue(dotNetObject.symbol)) {
            let { buildJsSymbol } = await import('./symbol');
            this.component.symbol = buildJsSymbol(dotNetObject.symbol) as any;
        }

        if (hasValue(dotNetObject.aggregateGeometries)) {
            this.component.aggregateGeometries = dotNetObject.aggregateGeometries;
        }
        if (hasValue(dotNetObject.attributes)) {
            this.component.attributes = dotNetObject.attributes;
        }
        if (hasValue(dotNetObject.origin)) {
            this.component.origin = dotNetObject.origin;
        }
        if (hasValue(dotNetObject.stackedAttributes)) {
            this.component.stackedAttributes = dotNetObject.stackedAttributes;
        }
        if (hasValue(dotNetObject.visible)) {
            this.component.visible = dotNetObject.visible;
        }
    }
    
    async getAttribute(name: any): Promise<any> {
        let result = this.component.getAttribute(name);
        
        return generateSerializableJson(result);
    }

    async getEffectivePopupTemplate(defaultPopupTemplateEnabled: any): Promise<any> {
        return this.component.getEffectivePopupTemplate(defaultPopupTemplateEnabled);
    }

    async getObjectId(): Promise<any> {
        let result = this.component.getObjectId();
        
        return generateSerializableJson(result);
    }

    async setAttribute(name: any,
        newValue: any): Promise<void> {
        this.component.setAttribute(name,
            newValue);
    }

    // region properties
    
    getAggregateGeometries(): any {
        if (!hasValue(this.component.aggregateGeometries)) {
            return null;
        }
        
        return generateSerializableJson(this.component.aggregateGeometries);
    }
    
    setAggregateGeometries(value: any): void {
        this.component.aggregateGeometries = JSON.parse(value);
    }
    
    async getGeometry(): Promise<any> {
        if (!hasValue(this.component.geometry)) {
            return null;
        }
        
        let { buildDotNetGeometry } = await import('./geometry');
        return buildDotNetGeometry(this.component.geometry);
    }
    
    async setGeometry(value: any): Promise<void> {
        let { buildJsGeometry } = await import('./geometry');
        this.component.geometry =  buildJsGeometry(value);
    }
    
    async getLayer(): Promise<any> {
        if (!hasValue(this.component.layer)) {
            return null;
        }
        
        let { buildDotNetLayer } = await import('./layer');
        return await buildDotNetLayer(this.component.layer);
    }
    
    async setLayer(value: any): Promise<void> {
        let { buildJsLayer } = await import('./layer');
        this.component.layer = await  buildJsLayer(value, this.layerId, this.viewId);
    }
    
    async getPopupTemplate(): Promise<any> {
        if (!hasValue(this.component.popupTemplate)) {
            return null;
        }
        
        let { buildDotNetPopupTemplate } = await import('./popupTemplate');
        return await buildDotNetPopupTemplate(this.component.popupTemplate);
    }
    
    async setPopupTemplate(value: any): Promise<void> {
        let { buildJsPopupTemplate } = await import('./popupTemplate');
        this.component.popupTemplate =  buildJsPopupTemplate(value, this.layerId, this.viewId);
    }
    
    async getSymbol(): Promise<any> {
        if (!hasValue(this.component.symbol)) {
            return null;
        }
        
        let { buildDotNetSymbol } = await import('./symbol');
        return buildDotNetSymbol(this.component.symbol);
    }
    
    async setSymbol(value: any): Promise<void> {
        let { buildJsSymbol } = await import('./symbol');
        this.component.symbol =  buildJsSymbol(value);
    }
    
    getProperty(prop: string): any {
        return this.component[prop];
    }
    
    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}


export async function buildJsAttributeBinsGraphicGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    if (!hasValue(dotNetObject)) {
        return null;
    }

    let properties: any = {};
    if (hasValue(dotNetObject.geometry)) {
        let { buildJsGeometry } = await import('./geometry');
        properties.geometry = buildJsGeometry(dotNetObject.geometry) as any;
    }
    if (hasValue(dotNetObject.layerId) && arcGisObjectRefs.hasOwnProperty(dotNetObject.layerId)) {
        properties.layer = arcGisObjectRefs[dotNetObject.layerId!];
    } else if (hasValue(dotNetObject.layer)) {
        let { buildJsLayer } = await import('./layer');
        properties.layer = await buildJsLayer(dotNetObject.layer, layerId, viewId);
    }
    if (hasValue(dotNetObject.popupTemplate)) {
        let { buildJsPopupTemplate } = await import('./popupTemplate');
        properties.popupTemplate = buildJsPopupTemplate(dotNetObject.popupTemplate, layerId, viewId) as any;
    }
    if (hasValue(dotNetObject.symbol)) {
        let { buildJsSymbol } = await import('./symbol');
        properties.symbol = buildJsSymbol(dotNetObject.symbol) as any;
    }

    if (hasValue(dotNetObject.aggregateGeometries)) {
        properties.aggregateGeometries = JSON.parse(dotNetObject.aggregateGeometries);
    }
    if (hasValue(dotNetObject.attributes)) {
        properties.attributes = dotNetObject.attributes;
    }
    if (hasValue(dotNetObject.origin)) {
        properties.origin = dotNetObject.origin;
    }
    if (hasValue(dotNetObject.stackedAttributes)) {
        properties.stackedAttributes = dotNetObject.stackedAttributes;
    }
    if (hasValue(dotNetObject.visible)) {
        properties.visible = dotNetObject.visible;
    }
    let jsAttributeBinsGraphic = new AttributeBinsGraphic(properties);

    let { default: AttributeBinsGraphicWrapper } = await import('./attributeBinsGraphic');
    let attributeBinsGraphicWrapper = new AttributeBinsGraphicWrapper(jsAttributeBinsGraphic);
    attributeBinsGraphicWrapper.geoBlazorId = dotNetObject.id;
    attributeBinsGraphicWrapper.viewId = viewId;
    attributeBinsGraphicWrapper.layerId = layerId;
    
    jsObjectRefs[dotNetObject.id] = attributeBinsGraphicWrapper;
    arcGisObjectRefs[dotNetObject.id] = jsAttributeBinsGraphic;
    
    return jsAttributeBinsGraphic;
}


export async function buildDotNetAttributeBinsGraphicGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }
    
    let dotNetAttributeBinsGraphic: any = {};
    
    if (hasValue(jsObject.geometry)) {
        let { buildDotNetGeometry } = await import('./geometry');
        dotNetAttributeBinsGraphic.geometry = buildDotNetGeometry(jsObject.geometry);
    }
    
    if (hasValue(jsObject.popupTemplate)) {
        let { buildDotNetPopupTemplate } = await import('./popupTemplate');
        dotNetAttributeBinsGraphic.popupTemplate = await buildDotNetPopupTemplate(jsObject.popupTemplate);
    }
    
    if (hasValue(jsObject.symbol)) {
        let { buildDotNetSymbol } = await import('./symbol');
        dotNetAttributeBinsGraphic.symbol = buildDotNetSymbol(jsObject.symbol);
    }
    
    if (hasValue(jsObject.aggregateGeometries)) {
        dotNetAttributeBinsGraphic.aggregateGeometries = generateSerializableJson(jsObject.aggregateGeometries);
    }
    
    if (hasValue(jsObject.attributes)) {
        dotNetAttributeBinsGraphic.attributes = removeCircularReferences(jsObject.attributes);
    }
    
    if (hasValue(jsObject.isAggregate)) {
        dotNetAttributeBinsGraphic.isAggregate = jsObject.isAggregate;
    }
    
    if (hasValue(jsObject.origin)) {
        dotNetAttributeBinsGraphic.origin = removeCircularReferences(jsObject.origin);
    }
    
    if (hasValue(jsObject.stackedAttributes)) {
        dotNetAttributeBinsGraphic.stackedAttributes = removeCircularReferences(jsObject.stackedAttributes);
    }
    
    if (hasValue(jsObject.visible)) {
        dotNetAttributeBinsGraphic.visible = jsObject.visible;
    }
    

    let geoBlazorId = lookupGeoBlazorId(jsObject);
    if (hasValue(geoBlazorId)) {
        dotNetAttributeBinsGraphic.id = geoBlazorId;
    }

    return dotNetAttributeBinsGraphic;
}

