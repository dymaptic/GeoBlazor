// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .ts file
import sceneViewerUtils = __esri.sceneViewerUtils;
import {arcGisObjectRefs, hasValue, jsObjectRefs} from './arcGisJsInterop';
import {IPropertyWrapper} from './definitions';

export default class SceneViewerUtilsGenerated implements IPropertyWrapper {
    public component: sceneViewerUtils;
    public geoBlazorId: string | null = null;
    public viewId: string | null = null;
    public layerId: string | null = null;

    constructor(component: sceneViewerUtils) {
        this.component = component;
    }

    // region methods

    unwrap() {
        return this.component;
    }

    async canSaveAs(webscene: any): Promise<any> {
        return this.component.canSaveAs(webscene);
    }

    async closeCatalogLayer(layerList: any): Promise<void> {
        let {buildJsLayerListWidget} = await import('./layerListWidget');
        let jsLayerList = await buildJsLayerListWidget(layerList, this.layerId, this.viewId) as any;
        this.component.closeCatalogLayer(jsLayerList);
    }

    async createTilingScheme(tileInfo: any): Promise<any> {
        let {buildJsTileInfo} = await import('./tileInfo');
        let jsTileInfo = await buildJsTileInfo(tileInfo, this.layerId, this.viewId) as any;
        return this.component.createTilingScheme(jsTileInfo);
    }

    async editorHasPendingEdits(viewModel: any): Promise<any> {
        let {buildJsEditorViewModel} = await import('./editorViewModel');
        let jsViewModel = await buildJsEditorViewModel(viewModel, this.layerId, this.viewId) as any;
        return this.component.editorHasPendingEdits(jsViewModel);
    }

    async editorNavigateBack(viewModel: any): Promise<void> {
        let {buildJsEditorViewModel} = await import('./editorViewModel');
        let jsViewModel = await buildJsEditorViewModel(viewModel, this.layerId, this.viewId) as any;
        await this.component.editorNavigateBack(jsViewModel);
    }

    async getCompatibleTileInfoForVTL(tileInfo: any,
                                      expectedTileSize: any): Promise<any> {
        let {buildJsTileInfo} = await import('./tileInfo');
        let jsTileInfo = await buildJsTileInfo(tileInfo, this.layerId, this.viewId) as any;
        return this.component.getCompatibleTileInfoForVTL(jsTileInfo,
            expectedTileSize);
    }

    async initializeSchemaValidators(): Promise<void> {
        this.component.initializeSchemaValidators();
    }

    async isHostedAgolServiceUrl(url: any): Promise<any> {
        return this.component.isHostedAgolServiceUrl(url);
    }

    async isSchemaValidationError(saveError: any): Promise<any> {
        return this.component.isSchemaValidationError(saveError);
    }

    async isSpatialReferenceSupported(spatialReference: any,
                                      viewingMode: any): Promise<any> {
        let {buildJsSpatialReference} = await import('./spatialReference');
        let jsSpatialReference = buildJsSpatialReference(spatialReference) as any;
        return this.component.isSpatialReferenceSupported(jsSpatialReference,
            viewingMode);
    }

    async isSupportedTileInfo(tileInfo: any): Promise<any> {
        let {buildJsTileInfo} = await import('./tileInfo');
        let jsTileInfo = await buildJsTileInfo(tileInfo, this.layerId, this.viewId) as any;
        return this.component.isSupportedTileInfo(jsTileInfo);
    }

    async renderSVG(swatch: any,
                    width: any,
                    height: any,
                    options: any): Promise<any> {
        return this.component.renderSVG(swatch,
            width,
            height,
            options);
    }

    async saveStateWarning(warningMessage: any,
                           error: any): Promise<void> {
        this.component.saveStateWarning(warningMessage,
            error);
    }

    async zoomDragBeginPoint(view: any): Promise<any> {
        return this.component.zoomDragBeginPoint(view);
    }

    // region properties

    getProperty(prop: string): any {
        return this.component[prop];
    }

    setProperty(prop: string, value: any): void {
        this.component[prop] = value;
    }
}

export async function buildJsSceneViewerUtilsGenerated(dotNetObject: any, layerId: string | null, viewId: string | null): Promise<any> {
    let jssceneViewerUtils: any = {}


    let {default: SceneViewerUtilsWrapper} = await import('./sceneViewerUtils');
    let sceneViewerUtilsWrapper = new SceneViewerUtilsWrapper(jssceneViewerUtils);
    sceneViewerUtilsWrapper.geoBlazorId = dotNetObject.id;
    sceneViewerUtilsWrapper.viewId = viewId;
    sceneViewerUtilsWrapper.layerId = layerId;

    // @ts-ignore
    let jsObjectRef = DotNet.createJSObjectReference(sceneViewerUtilsWrapper);
    jsObjectRefs[dotNetObject.id] = sceneViewerUtilsWrapper;
    arcGisObjectRefs[dotNetObject.id] = jssceneViewerUtils;
    let {buildDotNetSceneViewerUtils} = await import('./sceneViewerUtils');
    let dnInstantiatedObject = await buildDotNetSceneViewerUtils(jssceneViewerUtils);

    try {
        await dotNetObject.dotNetComponentReference.invokeMethodAsync('OnJsComponentCreated', jsObjectRef, JSON.stringify(dnInstantiatedObject));
    } catch (e) {
        console.error('Error invoking OnJsComponentCreated for SceneViewerUtils', e);
    }

    return jssceneViewerUtils;
}

export async function buildDotNetSceneViewerUtilsGenerated(jsObject: any): Promise<any> {
    if (!hasValue(jsObject)) {
        return null;
    }

    let dotNetSceneViewerUtils: any = {
        // @ts-ignore
        jsComponentReference: DotNet.createJSObjectReference(jsObject)
    };

    if (Object.values(arcGisObjectRefs).includes(jsObject)) {
        for (const k of Object.keys(arcGisObjectRefs)) {
            if (arcGisObjectRefs[k] === jsObject) {
                dotNetSceneViewerUtils.id = k;
                break;
            }
        }
    }

    return dotNetSceneViewerUtils;
}

