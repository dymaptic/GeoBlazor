// File auto-generated by dymaptic tooling. Any changes made here will be lost on future generation. To override functionality, use the relevant root .cs file.

namespace dymaptic.GeoBlazor.Core.Components.Widgets;


/// <summary>
///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html">GeoBlazor Docs</a>
///     A slider widget that can be used for filtering data, or gathering
///     numeric input from a user.
///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html">ArcGIS Maps SDK for JavaScript</a>
/// </summary>
public partial class SliderWidget
{

    /// <summary>
    ///     Parameterless constructor for use as a Razor Component.
    /// </summary>
    [ActivatorUtilitiesConstructor]
    public SliderWidget()
    {
    }

    /// <summary>
    ///     Constructor for use in C# code. Use named parameters (e.g., item1: value1, item2: value2) to set properties in any order.
    /// </summary>
    /// <param name="containerId">
    ///     The ID of the container element for the widget. The widget will be rendered within this container.
    /// </param>
    /// <param name="disabled">
    ///     When `true`, sets the slider to a disabled state so the user cannot interact
    ///     with it.
    ///     default false
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#disabled">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="draggableSegmentsEnabled">
    ///     Indicates if the user can drag the segment between thumbs
    ///     to update thumb positions.
    ///     default true
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#draggableSegmentsEnabled">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="effectiveMax">
    ///     When set, the user is restricted from moving slider thumbs to positions higher than
    ///     this value.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#effectiveMax">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="effectiveMin">
    ///     When set, the user is restricted from moving slider thumbs to positions less than
    ///     this value.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#effectiveMin">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="label">
    ///     The widget's default label.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#label">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="labelInputsEnabled">
    ///     Indicates whether to enable editing input values via keyboard input
    ///     when the user clicks a label.
    ///     default false
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labelInputsEnabled">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="layout">
    ///     Determines the layout/orientation of the Slider widget.
    ///     default "horizontal"
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#layout">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="max">
    ///     The maximum possible data/thumb value of the slider.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#max">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="min">
    ///     The minimum possible data/thumb value of the slider.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#min">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="precision">
    ///     Defines how slider thumb values should be rounded.
    ///     default 4
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#precision">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="rangeLabelInputsEnabled">
    ///     Indicates whether to enable editing range values via keyboard input
    ///     when the user clicks a <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#min">min</a> or <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#max">max</a> label.
    ///     default false
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#rangeLabelInputsEnabled">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="snapOnClickEnabled">
    ///     Indicates if the closest thumb will snap to the clicked location on the track.
    ///     default true
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#snapOnClickEnabled">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="steps">
    ///     Sets steps on the slider that restrict user input to specific values. If an array of numbers is passed to this property, the slider thumbs may only be moved to the positions specified in the array.
    /// </param>
    /// <param name="syncedSegmentsEnabled">
    ///     When `true`, all segments will sync together in updating thumb values when the user drags any segment.
    ///     default false
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#syncedSegmentsEnabled">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="thumbsConstrained">
    ///     When `false`, the user can freely move any slider thumb to any
    ///     position along the track.
    ///     default true
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#thumbsConstrained">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="values">
    ///     An array of numbers representing absolute thumb positions on the slider.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#values">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="inputCreatedFunction">
    ///     A function that provides the developer with access to the input elements when
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#rangeLabelInputsEnabled">rangeLabelInputsEnabled</a> and/or <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labelInputsEnabled">labelInputsEnabled</a> are set to `true`.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#inputCreatedFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="inputFormatFunction">
    ///     A function used to format user inputs.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#inputFormatFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="inputParseFunction">
    ///     Function used to parse slider inputs formatted by the <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#inputFormatFunction">inputFormatFunction</a>.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#inputParseFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="labelFormatFunction">
    ///     A function used to format labels.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labelFormatFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="thumbCreatedFunction">
    ///     Function that executes each time a thumb is created on the slider.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#thumbCreatedFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="tickConfigs">
    ///     When set, renders ticks along the slider track.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#tickConfigs">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="visible">
    ///     Indicates whether the widget is visible.
    ///     default true
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Widget.html#visible">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="visibleElements">
    ///     The visible elements that are displayed within the widget.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#visibleElements">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="doubleCollectionSteps">
    ///     Sets steps, or intervals, on the slider that restrict user
    ///     input to specific values.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#steps">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="doubleSteps">
    ///     Sets steps, or intervals, on the slider that restrict user
    ///     input to specific values.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#steps">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="icon">
    ///     Icon displayed in the widget's button.
    ///     default "caret-double-horizontal"
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#icon">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="mapView">
    ///     If the Widget is defined outside of the MapView, this link is required to connect them together.
    /// </param>
    /// <param name="position">
    ///     The position of the widget in relation to the map view.
    /// </param>
    /// <param name="viewModel">
    ///     The view model for the Slider widget.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#viewModel">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    /// <param name="widgetId">
    ///     The unique ID assigned to the widget when the widget is created.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Widget.html#id">ArcGIS Maps SDK for JavaScript</a>
    /// </param>
    public SliderWidget(
        string containerId,
        bool? disabled = null,
        bool? draggableSegmentsEnabled = null,
        double? effectiveMax = null,
        double? effectiveMin = null,
        string? label = null,
        bool? labelInputsEnabled = null,
        SliderLayout? layout = null,
        double? max = null,
        double? min = null,
        double? precision = null,
        bool? rangeLabelInputsEnabled = null,
        bool? snapOnClickEnabled = null,
        double[]? steps = null,
        bool? syncedSegmentsEnabled = null,
        bool? thumbsConstrained = null,
        IReadOnlyList<double>? values = null,
        InputCreatedFunction? inputCreatedFunction = null,
        SliderLabelFormatter? inputFormatFunction = null,
        InputParser? inputParseFunction = null,
        SliderLabelFormatter? labelFormatFunction = null,
        ThumbCreatedFunction? thumbCreatedFunction = null,
        IReadOnlyList<TickConfig>? tickConfigs = null,
        bool? visible = null,
        SliderVisibleElements? visibleElements = null,
        IReadOnlyList<double>? doubleCollectionSteps = null,
        double? doubleSteps = null,
        string? icon = null,
        MapView? mapView = null,
        OverlayPosition? position = null,
        SliderViewModel? viewModel = null,
        string? widgetId = null)
    {
        AllowRender = false;
#pragma warning disable BL0005
        ContainerId = containerId;
        Disabled = disabled;
        DraggableSegmentsEnabled = draggableSegmentsEnabled;
        EffectiveMax = effectiveMax;
        EffectiveMin = effectiveMin;
        Label = label;
        LabelInputsEnabled = labelInputsEnabled;
        Layout = layout;
        Max = max;
        Min = min;
        Precision = precision;
        RangeLabelInputsEnabled = rangeLabelInputsEnabled;
        SnapOnClickEnabled = snapOnClickEnabled;
        Steps = steps;
        SyncedSegmentsEnabled = syncedSegmentsEnabled;
        ThumbsConstrained = thumbsConstrained;
        Values = values;
        InputCreatedFunction = inputCreatedFunction;
        InputFormatFunction = inputFormatFunction;
        InputParseFunction = inputParseFunction;
        LabelFormatFunction = labelFormatFunction;
        ThumbCreatedFunction = thumbCreatedFunction;
        TickConfigs = tickConfigs;
        Visible = visible;
        VisibleElements = visibleElements;
        DoubleCollectionSteps = doubleCollectionSteps;
        DoubleSteps = doubleSteps;
        Icon = icon;
        MapView = mapView;
        Position = position;
        ViewModel = viewModel;
        WidgetId = widgetId;
#pragma warning restore BL0005    
    }
    
    
#region Public Properties / Blazor Parameters

    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetdoublecollectionsteps-property">GeoBlazor Docs</a>
    ///     Sets steps, or intervals, on the slider that restrict user
    ///     input to specific values.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#steps">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<double>? DoubleCollectionSteps { get; set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetdoublesteps-property">GeoBlazor Docs</a>
    ///     Sets steps, or intervals, on the slider that restrict user
    ///     input to specific values.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#steps">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public double? DoubleSteps { get; set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgeteffectivesegmentelements-property">GeoBlazor Docs</a>
    ///     The HTML Element nodes representing the slider segment between the <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#min">min</a> and <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#effectiveMin">effectiveMin</a>, and the segment between the
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#effectiveMax">effectiveMax</a> and <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#max">max</a>.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#effectiveSegmentElements">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public IReadOnlyList<ElementReference>? EffectiveSegmentElements { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetinputcreatedfunction-property">GeoBlazor Docs</a>
    ///     A function that provides the developer with access to the input elements when
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#rangeLabelInputsEnabled">rangeLabelInputsEnabled</a> and/or <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labelInputsEnabled">labelInputsEnabled</a> are set to `true`.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#inputCreatedFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    [JsonIgnore]
    public InputCreatedFunction? InputCreatedFunction { get; set; }
    
    /// <summary>
    ///    JS-invokable method that triggers the <see cref="InputCreatedFunction"/> function.
    ///     Should not be called by consuming code.
    /// </summary>
    [JSInvokable]
    public async Task OnJsInputCreatedFunction(ElementReference inputElement,
        InputCreatedFunctionType type,
        int thumbIndex)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
        
        if (InputCreatedFunction is not null)
        {
            await InputCreatedFunction.Invoke(inputElement,
                type,
                thumbIndex);
        }
    }
    
    /// <summary>
    ///     A convenience property that signifies whether a custom <see cref="InputCreatedFunction" /> function was registered.
    /// </summary>
    public bool HasInputCreatedFunction => InputCreatedFunction is not null;
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetinputformatfunction-property">GeoBlazor Docs</a>
    ///     A function used to format user inputs.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#inputFormatFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    public SliderLabelFormatter? InputFormatFunction { get; set; }
    
    /// <summary>
    ///     A convenience property that signifies whether a custom <see cref="InputFormatFunction" /> function was registered.
    /// </summary>
    public bool HasInputFormatFunction => InputFormatFunction is not null;
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetinputparsefunction-property">GeoBlazor Docs</a>
    ///     Function used to parse slider inputs formatted by the <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#inputFormatFunction">inputFormatFunction</a>.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#inputParseFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    public InputParser? InputParseFunction { get; set; }
    
    /// <summary>
    ///     A convenience property that signifies whether a custom <see cref="InputParseFunction" /> function was registered.
    /// </summary>
    public bool HasInputParseFunction => InputParseFunction is not null;
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetlabelelements-property">GeoBlazor Docs</a>
    ///     The HTML Element nodes representing <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labels">labels</a> attached to slider thumbs.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labelElements">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public IReadOnlyList<ElementReference>? LabelElements { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetlabelformatfunction-property">GeoBlazor Docs</a>
    ///     A function used to format labels.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labelFormatFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    public SliderLabelFormatter? LabelFormatFunction { get; set; }
    
    /// <summary>
    ///     A convenience property that signifies whether a custom <see cref="LabelFormatFunction" /> function was registered.
    /// </summary>
    public bool HasLabelFormatFunction => LabelFormatFunction is not null;
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetlabels-property">GeoBlazor Docs</a>
    ///     An array of strings associated with 'values' generated using an internal label formatter or
    ///     the values returned from <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labelFormatFunction">labelFormatFunction</a>.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#labels">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public LabelInfos? Labels { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetmaxlabelelement-property">GeoBlazor Docs</a>
    ///     The HTML Element node representing the <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#max">max</a> value label.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#maxLabelElement">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public ElementReference? MaxLabelElement { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetminlabelelement-property">GeoBlazor Docs</a>
    ///     The HTML Element node representing the <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#min">min</a> value label.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#minLabelElement">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public ElementReference? MinLabelElement { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetsegmentelements-property">GeoBlazor Docs</a>
    ///     The HTML Element nodes representing interactive slider segments.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#segmentElements">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public IReadOnlyList<ElementReference>? SegmentElements { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetstate-property">GeoBlazor Docs</a>
    ///     The current state of the widget.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#state">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public SliderState? State { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetthumbcreatedfunction-property">GeoBlazor Docs</a>
    ///     Function that executes each time a thumb is created on the slider.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#thumbCreatedFunction">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    [JsonIgnore]
    public ThumbCreatedFunction? ThumbCreatedFunction { get; set; }
    
    /// <summary>
    ///    JS-invokable method that triggers the <see cref="ThumbCreatedFunction"/> function.
    ///     Should not be called by consuming code.
    /// </summary>
    [JSInvokable]
    public async Task OnJsThumbCreatedFunction(int index,
        double value,
        ElementReference thumbElement,
        ElementReference labelElement)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
        
        if (ThumbCreatedFunction is not null)
        {
            await ThumbCreatedFunction.Invoke(index,
                value,
                thumbElement,
                labelElement);
        }
    }
    
    /// <summary>
    ///     A convenience property that signifies whether a custom <see cref="ThumbCreatedFunction" /> function was registered.
    /// </summary>
    public bool HasThumbCreatedFunction => ThumbCreatedFunction is not null;
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetthumbelements-property">GeoBlazor Docs</a>
    ///     The HTML Element nodes representing slider thumbs.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#thumbElements">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public IReadOnlyList<ElementReference>? ThumbElements { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgettickconfigs-property">GeoBlazor Docs</a>
    ///     When set, renders ticks along the slider track.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#tickConfigs">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<TickConfig>? TickConfigs { get; set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgettickelements-property">GeoBlazor Docs</a>
    ///     The HTML Element nodes representing slider ticks and their associated labels.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#tickElements">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public IReadOnlyList<IReadOnlyList<TickElementGroup>>? TickElements { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgettrackelement-property">GeoBlazor Docs</a>
    ///     The HTML Element node representing the slider track.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#trackElement">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonInclude]
    public ElementReference? TrackElement { get; protected set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetviewmodel-property">GeoBlazor Docs</a>
    ///     The view model for the Slider widget.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#viewModel">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public SliderViewModel? ViewModel { get; set; }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetvisibleelements-property">GeoBlazor Docs</a>
    ///     The visible elements that are displayed within the widget.
    ///     <a target="_blank" href="https://developers.arcgis.com/javascript/latest/api-reference/esri-widgets-Slider.html#visibleElements">ArcGIS Maps SDK for JavaScript</a>
    /// </summary>
    [ArcGISProperty]
    [Parameter]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public SliderVisibleElements? VisibleElements { get; set; }
    
#endregion

#region Property Getters

    /// <summary>
    ///     Asynchronously retrieve the current value of the Disabled property.
    /// </summary>
    public async Task<bool?> GetDisabled()
    {
        if (CoreJsModule is null)
        {
            return Disabled;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return Disabled;
        }

        // get the property value
        JsNullableBoolWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableBoolWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "disabled");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             Disabled = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(Disabled)] = Disabled;
        }
         
        return Disabled;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the DoubleCollectionSteps property.
    /// </summary>
    public async Task<IReadOnlyList<double>?> GetDoubleCollectionSteps()
    {
        if (CoreJsModule is null)
        {
            return DoubleCollectionSteps;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return DoubleCollectionSteps;
        }

        // get the property value
        IReadOnlyList<double>? result = await JsComponentReference!.InvokeAsync<IReadOnlyList<double>?>("getProperty",
            CancellationTokenSource.Token, "steps");
        if (result is not null)
        {
#pragma warning disable BL0005
             DoubleCollectionSteps = result;
#pragma warning restore BL0005
             ModifiedParameters[nameof(DoubleCollectionSteps)] = DoubleCollectionSteps;
        }
         
        return DoubleCollectionSteps;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the DoubleSteps property.
    /// </summary>
    public async Task<double?> GetDoubleSteps()
    {
        if (CoreJsModule is null)
        {
            return DoubleSteps;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return DoubleSteps;
        }

        // get the property value
        JsNullableDoubleWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableDoubleWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "doubleSteps");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             DoubleSteps = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(DoubleSteps)] = DoubleSteps;
        }
         
        return DoubleSteps;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the DraggableSegmentsEnabled property.
    /// </summary>
    public async Task<bool?> GetDraggableSegmentsEnabled()
    {
        if (CoreJsModule is null)
        {
            return DraggableSegmentsEnabled;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return DraggableSegmentsEnabled;
        }

        // get the property value
        JsNullableBoolWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableBoolWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "draggableSegmentsEnabled");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             DraggableSegmentsEnabled = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(DraggableSegmentsEnabled)] = DraggableSegmentsEnabled;
        }
         
        return DraggableSegmentsEnabled;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the EffectiveMax property.
    /// </summary>
    public async Task<double?> GetEffectiveMax()
    {
        if (CoreJsModule is null)
        {
            return EffectiveMax;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return EffectiveMax;
        }

        // get the property value
        JsNullableDoubleWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableDoubleWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "effectiveMax");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             EffectiveMax = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(EffectiveMax)] = EffectiveMax;
        }
         
        return EffectiveMax;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the EffectiveMin property.
    /// </summary>
    public async Task<double?> GetEffectiveMin()
    {
        if (CoreJsModule is null)
        {
            return EffectiveMin;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return EffectiveMin;
        }

        // get the property value
        JsNullableDoubleWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableDoubleWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "effectiveMin");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             EffectiveMin = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(EffectiveMin)] = EffectiveMin;
        }
         
        return EffectiveMin;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the EffectiveSegmentElements property.
    /// </summary>
    public async Task<IReadOnlyList<ElementReference>?> GetEffectiveSegmentElements()
    {
        if (CoreJsModule is null)
        {
            return EffectiveSegmentElements;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return EffectiveSegmentElements;
        }

        // get the property value
        IReadOnlyList<ElementReference>? result = await JsComponentReference!.InvokeAsync<IReadOnlyList<ElementReference>?>("getProperty",
            CancellationTokenSource.Token, "effectiveSegmentElements");
        if (result is not null)
        {
#pragma warning disable BL0005
             EffectiveSegmentElements = result;
#pragma warning restore BL0005
             ModifiedParameters[nameof(EffectiveSegmentElements)] = EffectiveSegmentElements;
        }
         
        return EffectiveSegmentElements;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the LabelElements property.
    /// </summary>
    public async Task<IReadOnlyList<ElementReference>?> GetLabelElements()
    {
        if (CoreJsModule is null)
        {
            return LabelElements;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return LabelElements;
        }

        // get the property value
        IReadOnlyList<ElementReference>? result = await JsComponentReference!.InvokeAsync<IReadOnlyList<ElementReference>?>("getProperty",
            CancellationTokenSource.Token, "labelElements");
        if (result is not null)
        {
#pragma warning disable BL0005
             LabelElements = result;
#pragma warning restore BL0005
             ModifiedParameters[nameof(LabelElements)] = LabelElements;
        }
         
        return LabelElements;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the LabelInputsEnabled property.
    /// </summary>
    public async Task<bool?> GetLabelInputsEnabled()
    {
        if (CoreJsModule is null)
        {
            return LabelInputsEnabled;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return LabelInputsEnabled;
        }

        // get the property value
        JsNullableBoolWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableBoolWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "labelInputsEnabled");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             LabelInputsEnabled = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(LabelInputsEnabled)] = LabelInputsEnabled;
        }
         
        return LabelInputsEnabled;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the Labels property.
    /// </summary>
    public async Task<LabelInfos?> GetLabels()
    {
        if (CoreJsModule is null)
        {
            return Labels;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return Labels;
        }

        // get the property value
        LabelInfos? result = await JsComponentReference!.InvokeAsync<LabelInfos?>("getProperty",
            CancellationTokenSource.Token, "labels");
        if (result is not null)
        {
#pragma warning disable BL0005
             Labels = result;
#pragma warning restore BL0005
             ModifiedParameters[nameof(Labels)] = Labels;
        }
         
        return Labels;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the Layout property.
    /// </summary>
    public async Task<SliderLayout?> GetLayout()
    {
        if (CoreJsModule is null)
        {
            return Layout;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return Layout;
        }

        // get the property value
        JsNullableEnumWrapper<SliderLayout>? result = await CoreJsModule!.InvokeAsync<JsNullableEnumWrapper<SliderLayout>?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "layout");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             Layout = (SliderLayout)result.Value.Value!;
#pragma warning restore BL0005
             ModifiedParameters[nameof(Layout)] = Layout;
        }
         
        return Layout;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the Max property.
    /// </summary>
    public async Task<double?> GetMax()
    {
        if (CoreJsModule is null)
        {
            return Max;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return Max;
        }

        // get the property value
        JsNullableDoubleWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableDoubleWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "max");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             Max = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(Max)] = Max;
        }
         
        return Max;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the MaxLabelElement property.
    /// </summary>
    public async Task<ElementReference?> GetMaxLabelElement()
    {
        if (CoreJsModule is null)
        {
            return MaxLabelElement;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return MaxLabelElement;
        }

        // get the property value
        JsNullableElementReferenceWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableElementReferenceWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "maxLabelElement");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             MaxLabelElement = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(MaxLabelElement)] = MaxLabelElement;
        }
         
        return MaxLabelElement;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the Min property.
    /// </summary>
    public async Task<double?> GetMin()
    {
        if (CoreJsModule is null)
        {
            return Min;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return Min;
        }

        // get the property value
        JsNullableDoubleWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableDoubleWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "min");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             Min = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(Min)] = Min;
        }
         
        return Min;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the MinLabelElement property.
    /// </summary>
    public async Task<ElementReference?> GetMinLabelElement()
    {
        if (CoreJsModule is null)
        {
            return MinLabelElement;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return MinLabelElement;
        }

        // get the property value
        JsNullableElementReferenceWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableElementReferenceWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "minLabelElement");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             MinLabelElement = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(MinLabelElement)] = MinLabelElement;
        }
         
        return MinLabelElement;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the Precision property.
    /// </summary>
    public async Task<double?> GetPrecision()
    {
        if (CoreJsModule is null)
        {
            return Precision;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return Precision;
        }

        // get the property value
        JsNullableDoubleWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableDoubleWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "precision");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             Precision = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(Precision)] = Precision;
        }
         
        return Precision;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the RangeLabelInputsEnabled property.
    /// </summary>
    public async Task<bool?> GetRangeLabelInputsEnabled()
    {
        if (CoreJsModule is null)
        {
            return RangeLabelInputsEnabled;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return RangeLabelInputsEnabled;
        }

        // get the property value
        JsNullableBoolWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableBoolWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "rangeLabelInputsEnabled");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             RangeLabelInputsEnabled = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(RangeLabelInputsEnabled)] = RangeLabelInputsEnabled;
        }
         
        return RangeLabelInputsEnabled;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the SegmentElements property.
    /// </summary>
    public async Task<IReadOnlyList<ElementReference>?> GetSegmentElements()
    {
        if (CoreJsModule is null)
        {
            return SegmentElements;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return SegmentElements;
        }

        // get the property value
        IReadOnlyList<ElementReference>? result = await JsComponentReference!.InvokeAsync<IReadOnlyList<ElementReference>?>("getProperty",
            CancellationTokenSource.Token, "segmentElements");
        if (result is not null)
        {
#pragma warning disable BL0005
             SegmentElements = result;
#pragma warning restore BL0005
             ModifiedParameters[nameof(SegmentElements)] = SegmentElements;
        }
         
        return SegmentElements;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the SnapOnClickEnabled property.
    /// </summary>
    public async Task<bool?> GetSnapOnClickEnabled()
    {
        if (CoreJsModule is null)
        {
            return SnapOnClickEnabled;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return SnapOnClickEnabled;
        }

        // get the property value
        JsNullableBoolWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableBoolWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "snapOnClickEnabled");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             SnapOnClickEnabled = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(SnapOnClickEnabled)] = SnapOnClickEnabled;
        }
         
        return SnapOnClickEnabled;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the State property.
    /// </summary>
    public async Task<SliderState?> GetState()
    {
        if (CoreJsModule is null)
        {
            return State;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return State;
        }

        // get the property value
        JsNullableEnumWrapper<SliderState>? result = await CoreJsModule!.InvokeAsync<JsNullableEnumWrapper<SliderState>?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "state");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             State = (SliderState)result.Value.Value!;
#pragma warning restore BL0005
             ModifiedParameters[nameof(State)] = State;
        }
         
        return State;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the SyncedSegmentsEnabled property.
    /// </summary>
    public async Task<bool?> GetSyncedSegmentsEnabled()
    {
        if (CoreJsModule is null)
        {
            return SyncedSegmentsEnabled;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return SyncedSegmentsEnabled;
        }

        // get the property value
        JsNullableBoolWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableBoolWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "syncedSegmentsEnabled");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             SyncedSegmentsEnabled = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(SyncedSegmentsEnabled)] = SyncedSegmentsEnabled;
        }
         
        return SyncedSegmentsEnabled;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the ThumbElements property.
    /// </summary>
    public async Task<IReadOnlyList<ElementReference>?> GetThumbElements()
    {
        if (CoreJsModule is null)
        {
            return ThumbElements;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return ThumbElements;
        }

        // get the property value
        IReadOnlyList<ElementReference>? result = await JsComponentReference!.InvokeAsync<IReadOnlyList<ElementReference>?>("getProperty",
            CancellationTokenSource.Token, "thumbElements");
        if (result is not null)
        {
#pragma warning disable BL0005
             ThumbElements = result;
#pragma warning restore BL0005
             ModifiedParameters[nameof(ThumbElements)] = ThumbElements;
        }
         
        return ThumbElements;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the ThumbsConstrained property.
    /// </summary>
    public async Task<bool?> GetThumbsConstrained()
    {
        if (CoreJsModule is null)
        {
            return ThumbsConstrained;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return ThumbsConstrained;
        }

        // get the property value
        JsNullableBoolWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableBoolWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "thumbsConstrained");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             ThumbsConstrained = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(ThumbsConstrained)] = ThumbsConstrained;
        }
         
        return ThumbsConstrained;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the TickConfigs property.
    /// </summary>
    public async Task<IReadOnlyList<TickConfig>?> GetTickConfigs()
    {
        if (CoreJsModule is null)
        {
            return TickConfigs;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return TickConfigs;
        }

        IReadOnlyList<TickConfig>? result = await JsComponentReference.InvokeAsync<IReadOnlyList<TickConfig>?>(
            "getTickConfigs", CancellationTokenSource.Token);
        
        if (result is not null)
        {
#pragma warning disable BL0005
            TickConfigs = result;
#pragma warning restore BL0005
            ModifiedParameters[nameof(TickConfigs)] = TickConfigs;
        }
        
        return TickConfigs;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the TickElements property.
    /// </summary>
    public async Task<IReadOnlyList<IReadOnlyList<TickElementGroup>>?> GetTickElements()
    {
        if (CoreJsModule is null)
        {
            return TickElements;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return TickElements;
        }

        // get the property value
        IReadOnlyList<IReadOnlyList<TickElementGroup>>? result = await JsComponentReference!.InvokeAsync<IReadOnlyList<IReadOnlyList<TickElementGroup>>?>("getProperty",
            CancellationTokenSource.Token, "tickElements");
        if (result is not null)
        {
#pragma warning disable BL0005
             TickElements = result;
#pragma warning restore BL0005
             ModifiedParameters[nameof(TickElements)] = TickElements;
        }
         
        return TickElements;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the TrackElement property.
    /// </summary>
    public async Task<ElementReference?> GetTrackElement()
    {
        if (CoreJsModule is null)
        {
            return TrackElement;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return TrackElement;
        }

        // get the property value
        JsNullableElementReferenceWrapper? result = await CoreJsModule!.InvokeAsync<JsNullableElementReferenceWrapper?>("getNullableValueTypedProperty",
            CancellationTokenSource.Token, JsComponentReference, "trackElement");
        if (result is { Value: not null })
        {
#pragma warning disable BL0005
             TrackElement = result.Value.Value;
#pragma warning restore BL0005
             ModifiedParameters[nameof(TrackElement)] = TrackElement;
        }
         
        return TrackElement;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the Values property.
    /// </summary>
    public async Task<IReadOnlyList<double>?> GetValues()
    {
        if (CoreJsModule is null)
        {
            return Values;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return Values;
        }

        // get the property value
        IReadOnlyList<double>? result = await JsComponentReference!.InvokeAsync<IReadOnlyList<double>?>("getProperty",
            CancellationTokenSource.Token, "values");
        if (result is not null)
        {
#pragma warning disable BL0005
             Values = result;
#pragma warning restore BL0005
             ModifiedParameters[nameof(Values)] = Values;
        }
         
        return Values;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the ViewModel property.
    /// </summary>
    public async Task<SliderViewModel?> GetViewModel()
    {
        if (CoreJsModule is null)
        {
            return ViewModel;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return ViewModel;
        }

        SliderViewModel? result = await JsComponentReference.InvokeAsync<SliderViewModel?>(
            "getViewModel", CancellationTokenSource.Token);
        
        if (result is not null)
        {
            if (ViewModel is not null)
            {
                result.Id = ViewModel.Id;
            }
            
#pragma warning disable BL0005
            ViewModel = result;
#pragma warning restore BL0005
            ModifiedParameters[nameof(ViewModel)] = ViewModel;
        }
        
        return ViewModel;
    }
    
    /// <summary>
    ///     Asynchronously retrieve the current value of the VisibleElements property.
    /// </summary>
    public async Task<SliderVisibleElements?> GetVisibleElements()
    {
        if (CoreJsModule is null)
        {
            return VisibleElements;
        }
        
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
        
        if (JsComponentReference is null)
        {
            return VisibleElements;
        }

        SliderVisibleElements? result = await JsComponentReference.InvokeAsync<SliderVisibleElements?>(
            "getVisibleElements", CancellationTokenSource.Token);
        
        if (result is not null)
        {
#pragma warning disable BL0005
            VisibleElements = result;
#pragma warning restore BL0005
            ModifiedParameters[nameof(VisibleElements)] = VisibleElements;
        }
        
        return VisibleElements;
    }
    
#endregion

#region Property Setters

    /// <summary>
    ///    Asynchronously set the value of the Disabled property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetDisabled(bool? value)
    {
#pragma warning disable BL0005
        Disabled = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(Disabled)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "disabled", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the DoubleCollectionSteps property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetDoubleCollectionSteps(IReadOnlyList<double>? value)
    {
#pragma warning disable BL0005
        DoubleCollectionSteps = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(DoubleCollectionSteps)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "steps", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the DoubleSteps property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetDoubleSteps(double? value)
    {
#pragma warning disable BL0005
        DoubleSteps = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(DoubleSteps)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "steps", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the DraggableSegmentsEnabled property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetDraggableSegmentsEnabled(bool? value)
    {
#pragma warning disable BL0005
        DraggableSegmentsEnabled = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(DraggableSegmentsEnabled)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "draggableSegmentsEnabled", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the EffectiveMax property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetEffectiveMax(double? value)
    {
#pragma warning disable BL0005
        EffectiveMax = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(EffectiveMax)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "effectiveMax", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the EffectiveMin property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetEffectiveMin(double? value)
    {
#pragma warning disable BL0005
        EffectiveMin = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(EffectiveMin)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "effectiveMin", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the LabelInputsEnabled property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetLabelInputsEnabled(bool? value)
    {
#pragma warning disable BL0005
        LabelInputsEnabled = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(LabelInputsEnabled)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "labelInputsEnabled", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the Layout property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetLayout(SliderLayout? value)
    {
#pragma warning disable BL0005
        Layout = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(Layout)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "layout", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the Max property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetMax(double? value)
    {
#pragma warning disable BL0005
        Max = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(Max)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "max", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the Min property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetMin(double? value)
    {
#pragma warning disable BL0005
        Min = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(Min)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "min", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the Precision property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetPrecision(double? value)
    {
#pragma warning disable BL0005
        Precision = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(Precision)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "precision", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the RangeLabelInputsEnabled property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetRangeLabelInputsEnabled(bool? value)
    {
#pragma warning disable BL0005
        RangeLabelInputsEnabled = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(RangeLabelInputsEnabled)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "rangeLabelInputsEnabled", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the SnapOnClickEnabled property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetSnapOnClickEnabled(bool? value)
    {
#pragma warning disable BL0005
        SnapOnClickEnabled = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(SnapOnClickEnabled)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "snapOnClickEnabled", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the SyncedSegmentsEnabled property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetSyncedSegmentsEnabled(bool? value)
    {
#pragma warning disable BL0005
        SyncedSegmentsEnabled = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(SyncedSegmentsEnabled)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "syncedSegmentsEnabled", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the ThumbsConstrained property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetThumbsConstrained(bool? value)
    {
#pragma warning disable BL0005
        ThumbsConstrained = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(ThumbsConstrained)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "thumbsConstrained", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the TickConfigs property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetTickConfigs(IReadOnlyList<TickConfig>? value)
    {
        if (value is not null)
        {
            foreach (TickConfig item in value)
            {
                item.CoreJsModule = CoreJsModule;
                item.Parent = this;
                item.Layer = Layer;
                item.View = View;
            }
        }
        
#pragma warning disable BL0005
        TickConfigs = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(TickConfigs)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await JsComponentReference.InvokeVoidAsync("setTickConfigs", 
            CancellationTokenSource.Token, value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the Values property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetValues(IReadOnlyList<double>? value)
    {
#pragma warning disable BL0005
        Values = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(Values)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await CoreJsModule.InvokeVoidAsync("setProperty", CancellationTokenSource.Token,
            JsComponentReference, "values", value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the ViewModel property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetViewModel(SliderViewModel? value)
    {
        if (value is not null)
        {
            value.CoreJsModule  = CoreJsModule;
            value.Parent = this;
            value.Layer = Layer;
            value.View = View;
        } 
        
#pragma warning disable BL0005
        ViewModel = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(ViewModel)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await JsComponentReference.InvokeVoidAsync("setViewModel", 
            CancellationTokenSource.Token, value);
    }
    
    /// <summary>
    ///    Asynchronously set the value of the VisibleElements property after render.
    /// </summary>
    /// <param name="value">
    ///     The value to set.
    /// </param>
    public async Task SetVisibleElements(SliderVisibleElements? value)
    {
        if (value is not null)
        {
            value.CoreJsModule  = CoreJsModule;
            value.Parent = this;
            value.Layer = Layer;
            value.View = View;
        } 
        
#pragma warning disable BL0005
        VisibleElements = value;
#pragma warning restore BL0005
        ModifiedParameters[nameof(VisibleElements)] = value;
        
        if (CoreJsModule is null)
        {
            return;
        }
    
        try 
        {
            JsComponentReference ??= await CoreJsModule.InvokeAsync<IJSObjectReference?>(
                "getJsComponent", CancellationTokenSource.Token, Id);
        }
        catch (JSException)
        {
            // this is expected if the component is not yet built
        }
    
        if (JsComponentReference is null)
        {
            return;
        }
        
        await JsComponentReference.InvokeVoidAsync("setVisibleElements", 
            CancellationTokenSource.Token, value);
    }
    
#endregion

#region Add to Collection Methods

    /// <summary>
    ///     Asynchronously adds elements to the TickConfigs property.
    /// </summary>
    /// <param name="values">
    ///    The elements to add.
    /// </param>
    public async Task AddToTickConfigs(params TickConfig[] values)
    {
        TickConfig[] join = TickConfigs is null
            ? values
            : [..TickConfigs, ..values];
        await SetTickConfigs(join);
    }
    
    /// <summary>
    ///     Asynchronously adds elements to the Values property.
    /// </summary>
    /// <param name="values">
    ///    The elements to add.
    /// </param>
    public async Task AddToValues(params double[] values)
    {
        double[] join = Values is null
            ? values
            : [..Values, ..values];
        await SetValues(join);
    }
    
#endregion

#region Remove From Collection Methods

    
    /// <summary>
    ///     Asynchronously remove an element from the TickConfigs property.
    /// </summary>
    /// <param name="values">
    ///    The elements to remove.
    /// </param>
    public async Task RemoveFromTickConfigs(params TickConfig[] values)
    {
        if (TickConfigs is null)
        {
            return;
        }
        await SetTickConfigs(TickConfigs.Except(values).ToArray());
    }
    
    
    /// <summary>
    ///     Asynchronously remove an element from the Values property.
    /// </summary>
    /// <param name="values">
    ///    The elements to remove.
    /// </param>
    public async Task RemoveFromValues(params double[] values)
    {
        if (Values is null)
        {
            return;
        }
        await SetValues(Values.Except(values).ToArray());
    }
    
#endregion

#region Event Handlers

    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsMaxChange(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderMaxChangeEvent? maxChangeEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderMaxChangeEvent>();
        if (maxChangeEvent is not null)
        {
            await OnMaxChange.InvokeAsync(maxChangeEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonmaxchange-property">GeoBlazor Docs</a>
    ///     Event Listener for MaxChange.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderMaxChangeEvent> OnMaxChange { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasMaxChangeListener => OnMaxChange.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsMaxClick(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderMaxClickEvent? maxClickEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderMaxClickEvent>();
        if (maxClickEvent is not null)
        {
            await OnMaxClick.InvokeAsync(maxClickEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonmaxclick-property">GeoBlazor Docs</a>
    ///     Event Listener for MaxClick.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderMaxClickEvent> OnMaxClick { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasMaxClickListener => OnMaxClick.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsMinChange(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderMinChangeEvent? minChangeEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderMinChangeEvent>();
        if (minChangeEvent is not null)
        {
            await OnMinChange.InvokeAsync(minChangeEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonminchange-property">GeoBlazor Docs</a>
    ///     Event Listener for MinChange.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderMinChangeEvent> OnMinChange { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasMinChangeListener => OnMinChange.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsMinClick(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderMinClickEvent? minClickEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderMinClickEvent>();
        if (minClickEvent is not null)
        {
            await OnMinClick.InvokeAsync(minClickEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonminclick-property">GeoBlazor Docs</a>
    ///     Event Listener for MinClick.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderMinClickEvent> OnMinClick { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasMinClickListener => OnMinClick.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsSegmentClick(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderSegmentClickEvent? segmentClickEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderSegmentClickEvent>();
        if (segmentClickEvent is not null)
        {
            await OnSegmentClick.InvokeAsync(segmentClickEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonsegmentclick-property">GeoBlazor Docs</a>
    ///     Event Listener for SegmentClick.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderSegmentClickEvent> OnSegmentClick { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasSegmentClickListener => OnSegmentClick.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsSegmentDrag(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderSegmentDragEvent? segmentDragEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderSegmentDragEvent>();
        if (segmentDragEvent is not null)
        {
            await OnSegmentDrag.InvokeAsync(segmentDragEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonsegmentdrag-property">GeoBlazor Docs</a>
    ///     Event Listener for SegmentDrag.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderSegmentDragEvent> OnSegmentDrag { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasSegmentDragListener => OnSegmentDrag.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsThumbChange(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderThumbChangeEvent? thumbChangeEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderThumbChangeEvent>();
        if (thumbChangeEvent is not null)
        {
            await OnThumbChange.InvokeAsync(thumbChangeEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonthumbchange-property">GeoBlazor Docs</a>
    ///     Event Listener for ThumbChange.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderThumbChangeEvent> OnThumbChange { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasThumbChangeListener => OnThumbChange.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsThumbClick(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderThumbClickEvent? thumbClickEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderThumbClickEvent>();
        if (thumbClickEvent is not null)
        {
            await OnThumbClick.InvokeAsync(thumbClickEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonthumbclick-property">GeoBlazor Docs</a>
    ///     Event Listener for ThumbClick.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderThumbClickEvent> OnThumbClick { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasThumbClickListener => OnThumbClick.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsThumbDrag(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderThumbDragEvent? thumbDragEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderThumbDragEvent>();
        if (thumbDragEvent is not null)
        {
            await OnThumbDrag.InvokeAsync(thumbDragEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetonthumbdrag-property">GeoBlazor Docs</a>
    ///     Event Listener for ThumbDrag.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderThumbDragEvent> OnThumbDrag { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasThumbDragListener => OnThumbDrag.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsTickClick(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderTickClickEvent? tickClickEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderTickClickEvent>();
        if (tickClickEvent is not null)
        {
            await OnTickClick.InvokeAsync(tickClickEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetontickclick-property">GeoBlazor Docs</a>
    ///     Event Listener for TickClick.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderTickClickEvent> OnTickClick { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasTickClickListener => OnTickClick.HasDelegate;
    
    /// <summary>
    ///     JavaScript-Invokable Method for internal use only.
    /// </summary>
    [JSInvokable]
    public async Task OnJsTrackClick(IJSStreamReference jsStreamRef)
    {
        if (IsDisposed)
        {
            // cancel if the component is disposed
            return;
        }
    
        SliderTrackClickEvent? trackClickEvent = await jsStreamRef.ReadJsStreamReferenceAsJSON<SliderTrackClickEvent>();
        if (trackClickEvent is not null)
        {
            await OnTrackClick.InvokeAsync(trackClickEvent);
        }
    }
    
    /// <summary>
    ///     <a target="_blank" href="https://docs.geoblazor.com/pages/classes/dymaptic.GeoBlazor.Core.Components.Widgets.SliderWidget.html#sliderwidgetontrackclick-property">GeoBlazor Docs</a>
    ///     Event Listener for TrackClick.
    /// </summary>
    [Parameter]
    [JsonIgnore]
    public EventCallback<SliderTrackClickEvent> OnTrackClick { get; set; }
   
    /// <summary>
    ///     Used in JavaScript layer to determine if the event listener is registered.
    /// </summary>
    public bool HasTrackClickListener => OnTrackClick.HasDelegate;
    
#endregion


    /// <inheritdoc />
    protected override async ValueTask<bool> RegisterGeneratedChildComponent(MapComponent child)
    {
        switch (child)
        {
            case TickConfig tickConfigs:
                TickConfigs ??= [];
                if (!TickConfigs.Contains(tickConfigs))
                {
                    TickConfigs = [..TickConfigs, tickConfigs];
                    ModifiedParameters[nameof(TickConfigs)] = TickConfigs;
                    if (MapRendered)
                    {
                        await UpdateWidget();
                    }
                }
                
                return true;
            case SliderViewModel viewModel:
                if (viewModel != ViewModel)
                {
                    ViewModel = viewModel;
                    ModifiedParameters[nameof(ViewModel)] = ViewModel;
                    if (MapRendered)
                    {
                        await UpdateWidget();
                    }
                }
                
                return true;
            case SliderVisibleElements visibleElements:
                if (visibleElements != VisibleElements)
                {
                    VisibleElements = visibleElements;
                    ModifiedParameters[nameof(VisibleElements)] = VisibleElements;
                    if (MapRendered)
                    {
                        await UpdateWidget();
                    }
                }
                
                return true;
            default:
                return await base.RegisterGeneratedChildComponent(child);
        }
    }

    /// <inheritdoc />
    protected override async ValueTask<bool> UnregisterGeneratedChildComponent(MapComponent child)
    {
        switch (child)
        {
            case TickConfig tickConfigs:
                TickConfigs = TickConfigs?.Where(t => t != tickConfigs).ToList();
                ModifiedParameters[nameof(TickConfigs)] = TickConfigs;
                return true;
            case SliderViewModel _:
                ViewModel = null;
                ModifiedParameters[nameof(ViewModel)] = ViewModel;
                return true;
            case SliderVisibleElements _:
                VisibleElements = null;
                ModifiedParameters[nameof(VisibleElements)] = VisibleElements;
                return true;
            default:
                return await base.UnregisterGeneratedChildComponent(child);
        }
    }
    
    /// <inheritdoc />
    public override void ValidateRequiredGeneratedChildren()
    {
    
        if (TickConfigs is not null)
        {
            foreach (TickConfig child in TickConfigs)
            {
                child.ValidateRequiredGeneratedChildren();
            }
        }
        ViewModel?.ValidateRequiredGeneratedChildren();
        VisibleElements?.ValidateRequiredGeneratedChildren();
        base.ValidateRequiredGeneratedChildren();
    }
      
}
