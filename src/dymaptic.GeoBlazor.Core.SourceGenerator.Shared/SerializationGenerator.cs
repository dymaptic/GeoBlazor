using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;


namespace dymaptic.GeoBlazor.Core.SourceGenerator.Shared;

/// <summary>
///     Generates serialization data for methods and classes marked with the appropriate attributes.
/// </summary>
public static class SerializationGenerator
{
    public static void GenerateSerializationDataClass(SourceProductionContext context,
        ImmutableArray<SerializableMethodRecord> serializedMethodsCollection,
        Dictionary<string, ProtoMessageDefinition> protoDefinitions, bool isPro, bool isTest)
    {
        try
        {
            ProcessHelper.Log(nameof(SerializationGenerator),
                "Generating serialized data class...",
                DiagnosticSeverity.Info,
                context);

            string className = isPro ? "ProSerializationData" : "CoreSerializationData";

            StringBuilder classBuilder = new($$"""
                                               // <auto-generated/>

                                               #nullable enable
                                               
                                               {{(isPro ? "using dymaptic.GeoBlazor.Core.Serialization;" : "")}}
                                               using System.Collections;
                                               using FieldInfo = dymaptic.GeoBlazor.Core.Components.FieldInfo;

                                               namespace dymaptic.GeoBlazor.{{(isPro ? "Pro" : "Core")}}.Serialization;

                                               /// <summary>
                                               ///     This class is generated by a source generator and contains pre-analyzed serialization information.
                                               /// </summary>
                                               internal class {{className}}: ISerializationData
                                               {
                                                   
                                               """);

            if (isPro)
            {
                classBuilder.AppendLine("""
                                            public ProSerializationData(CoreSerializationData coreData)
                                            {
                                                _coreData = coreData;
                                            }
                                            
                                            private readonly CoreSerializationData _coreData;
                                            
                                        """);
            }
            
            classBuilder.AppendLine(GenerateExtensionMethods(protoDefinitions, isPro));

            classBuilder.AppendLine(
                GenerateSerializableMethodRecords(serializedMethodsCollection, protoDefinitions, isPro));

            classBuilder.AppendLine("}");
            
            ProcessHelper.Log(nameof(SerializationGenerator),
                $"Generated serialized data class: {className}.g.cs",
                DiagnosticSeverity.Info,
                context);

            if (isTest)
            {
                ProcessHelper.Log(nameof(SerializationGenerator),
                    $"Skipping generating file for test.",
                    DiagnosticSeverity.Info,
                    context);
            }
            else
            {
                context.AddSource($"{className}.g.cs", classBuilder.ToString());
            }
        }
        catch (Exception ex)
        {
            ProcessHelper.Log(nameof(SerializationGenerator),
                $"Error generating serialized data class: {ex}",
                DiagnosticSeverity.Error,
                context);
        }
    }
    
    private static string GenerateExtensionMethods(Dictionary<string, ProtoMessageDefinition> protoDefinitions, bool isPro)
    {
        if (isPro)
        {
            return """
                       /// <summary>
                       ///     Convenience method to deserialize an <see cref="IJSStreamReference" /> to a specific type via protobuf.
                       /// </summary>
                       public async Task<T?> ReadJsProtobufStreamReference<T>(IJSStreamReference jsStreamReference, 
                           Type returnType, long maxAllowedSize = 1_000_000_000)
                       {
                            return await _coreData.ReadJsProtobufStreamReference<T>(jsStreamReference, returnType, maxAllowedSize);
                       }
                       
                       /// <summary>
                       ///     Convenience method to generate a Protobuf serialized parameter.
                       /// </summary>
                       public object GenerateProtobufParameter(object value, Type serializableType, bool isServer)
                       {
                            return _coreData.GenerateProtobufParameter(value, serializableType, isServer);
                       }
                       
                       /// <summary>
                       ///     Convenience method to generate a Protobuf serialized collection parameter.
                       /// </summary>
                       public object GenerateProtobufCollectionParameter(IList items, Type serializableType, bool isServer)
                       {
                           return _coreData.GenerateProtobufCollectionParameter(items, serializableType, isServer);
                       }
                       
                       /// <summary>
                       ///     A collection of types that can be serialized to Protobuf
                       /// </summary>
                       public Dictionary<Type, Type> ProtoContractTypes => _coreData.ProtoContractTypes;
                       
                       /// <summary>
                       ///     A collection of types that can be serialized to Protobuf as collections of a specific Type
                       /// </summary>
                       public Dictionary<Type, Type> ProtoCollectionTypes => _coreData.ProtoCollectionTypes;
                       
                   """;
        }
        
        StringBuilder extensionMethods = new(
                """
                    /// <summary>
                    ///     Convenience method to deserialize an <see cref="IJSStreamReference" /> to a specific type via protobuf.
                    /// </summary>
                    public async Task<T?> ReadJsProtobufStreamReference<T>(IJSStreamReference jsStreamReference, 
                        Type returnType, long maxAllowedSize = 1_000_000_000)
                    {
                        await using Stream stream = await jsStreamReference.OpenReadStreamAsync(maxAllowedSize);
                        using MemoryStream memoryStream = new();
                        await stream.CopyToAsync(memoryStream);
                        memoryStream.Seek(0, SeekOrigin.Begin);
                        
                        string typeName = returnType.Name.Replace("SerializationRecord", "");
                
                        switch (typeName) 
                        {
                
                """);
            
            StringBuilder protoTypeDictionary = new(
                """
                    /// <summary>
                    ///     A collection of types that can be serialized to Protobuf
                    /// </summary>
                    public Dictionary<Type, Type> ProtoContractTypes => _protoContractTypes;
                    
                    private readonly Dictionary<Type, Type> _protoContractTypes = new()
                    {
                
                """);
            
            StringBuilder protoCollectionTypeDictionary = new(
                """
                    /// <summary>
                    ///     A collection of types that can be serialized to Protobuf as collections of a specific Type
                    /// </summary>
                    public Dictionary<Type, Type> ProtoCollectionTypes => _protoCollectionTypes;
                    
                    private readonly Dictionary<Type, Type> _protoCollectionTypes = new()
                    {
                
                """);

            StringBuilder protoMemberGenerationMethod = new(
                """
                    /// <summary>
                    ///     Convenience method to generate a Protobuf serialized parameter.
                    /// </summary>
                    public object GenerateProtobufParameter(object value, Type serializableType, bool isServer)
                    {
                        MemoryStream memoryStream = new();
                        switch (serializableType.Name)
                        {
                
                """);

            StringBuilder protoCollectionGenerationMethod = new(
                """
                    /// <summary>
                    ///     Convenience method to generate a Protobuf serialized collection parameter.
                    /// </summary>
                    public object GenerateProtobufCollectionParameter(IList items, Type serializableType, bool isServer)
                    {
                        MemoryStream memoryStream = new();
                        string typeName = $"{serializableType.Name}Collection";
                        switch (serializableType.Name)
                        {
                
                """);

            List<ProtoMessageDefinition> protoMessageDefinitions = protoDefinitions
                .OrderBy(kvp => kvp.Key)
                .Select(kvp => kvp.Value)
                .ToList();

            List<ProtoMessageDefinition> singleProtoDefinitions = protoMessageDefinitions
                .Where(p => !p.Name.EndsWith("Collection"))
                .ToList();

            List<ProtoMessageDefinition> collectionProtoDefinitions = protoMessageDefinitions
                .Where(p => p.Name.EndsWith("Collection"))
                .ToList();
                
            for (int i = 0; i < singleProtoDefinitions.Count; i++)
            {
                ProtoMessageDefinition definition = singleProtoDefinitions[i];
                if (definition.Name == "MapComponent")
                {
                    continue;
                }

                string serializationRecordType = definition.Name + "SerializationRecord";

                string geoblazorType = definition.GeoBlazorTypeIsInterface
                    ? $"I{definition.Name}"
                    : definition.Name;
                
                string variableName = ProtobufDefinitionsGenerator.ToLowerFirstChar(definition.Name);

                extensionMethods.AppendLine(
                    $$"""
                                  case "{{definition.Name}}":
                                      {{definition.Name}}SerializationRecord {{variableName}} = 
                                          Serializer.Deserialize<{{definition.Name}}SerializationRecord>(memoryStream);
                                      if ({{variableName}}.IsNull)
                                      {
                                          return default!;
                                      }
                                      return (T?)(object?){{variableName}}?.FromSerializationRecord();
                      """);
                    
                protoTypeDictionary.AppendLine(
                    $$"""
                              { typeof({{geoblazorType}}), typeof({{serializationRecordType}}) }{{(i < singleProtoDefinitions.Count - 1 ? "," : "")}}
                      """);
                
                if (definition.Name == "Attribute")
                {
                    // Attribute is not a GeoBlazor type so skip next injection
                    continue;
                }
                
                protoMemberGenerationMethod.AppendLine(
                    $$"""
                                case "{{definition.Name}}":
                                    {{definition.Name}}SerializationRecord {{variableName}} = 
                                        (({{geoblazorType}})value).ToProtobuf();
                                    Serializer.Serialize(memoryStream, {{variableName}});
                                    
                                    break;
                    """);
            }
            
            for (int i = 0; i < collectionProtoDefinitions.Count; i++)
            {
                ProtoMessageDefinition definition = collectionProtoDefinitions[i];
                if (definition.Name == "MapComponentCollection")
                {
                    continue;
                }

                string serializationRecordType = definition.Name + "SerializationRecord";
                
                ProtoMessageDefinition singleDefinition = protoMessageDefinitions
                    .First(d => d.Name == definition.Name.Replace("Collection", ""));
                
                string geoblazorType = singleDefinition.GeoBlazorTypeIsInterface
                    ? $"I{singleDefinition.Name}"
                    : singleDefinition.Name;
                
                string variableName = ProtobufDefinitionsGenerator.ToLowerFirstChar(definition.Name);

                extensionMethods.AppendLine(
                    $$"""
                                  case "{{definition.Name}}":
                                      {{serializationRecordType}} {{variableName}} = 
                                          Serializer.Deserialize<{{serializationRecordType}}>(memoryStream);
                                      return (T?)(object?){{variableName}}?.Items?.Select(i => i.FromSerializationRecord()).ToArray();
                      """); 
                    
                protoCollectionTypeDictionary.AppendLine(
                    $$"""
                              { typeof({{geoblazorType}}), typeof({{serializationRecordType}}) }{{(i < collectionProtoDefinitions.Count - 1 ? "," : "")}}
                      """);

                if (definition.Name == "AttributeCollection")
                {
                    // Attribute is not a GeoBlazor type so skip next injection
                    continue;
                }
                
                protoCollectionGenerationMethod.AppendLine(
                    $$"""
                                  case "{{definition.Name}}":
                                      {{definition.Name}}SerializationRecord {{variableName}} = 
                                          new(items.Cast<{{geoblazorType}}>().Select(i => i.ToProtobuf()).ToArray());
                                      Serializer.Serialize(memoryStream, {{variableName}});
                                      
                                      break;
                      """);
            }

            protoTypeDictionary.AppendLine("    };");
            protoCollectionTypeDictionary.AppendLine("    };");
            
            extensionMethods.AppendLine(
                """
                        }
                        
                        return default!;
                    }
                """);

            protoMemberGenerationMethod.AppendLine(
                """
                        }
                        
                        memoryStream.Seek(0, SeekOrigin.Begin);
                
                        if (isServer)
                        {
                            return new DotNetStreamReference(memoryStream);
                        }
                        
                        byte[] data = memoryStream.ToArray();
                        memoryStream.Dispose();
                        
                        return data;
                    }
                """);
            
            protoCollectionGenerationMethod.AppendLine(
                """
                        }
                        
                        memoryStream.Seek(0, SeekOrigin.Begin);
                
                        if (isServer)
                        {
                            return new DotNetStreamReference(memoryStream);
                        }
                        
                        byte[] data = memoryStream.ToArray();
                        memoryStream.Dispose();
                        
                        return data;
                    }
                """);

            return $"""
                    {extensionMethods}
                    
                    {protoMemberGenerationMethod}
                    
                    {protoCollectionGenerationMethod}
                    
                    {protoTypeDictionary}
                    
                    {protoCollectionTypeDictionary}
                    """;
    }
    
    private static string GenerateSerializableMethodRecords(
        ImmutableArray<SerializableMethodRecord> serializedMethodsCollection,
        Dictionary<string, ProtoMessageDefinition> protoDefinitions, bool isPro)
    {
        StringBuilder outputBuilder;

        if (isPro)
        {
            outputBuilder = new(
                """
                    /// <summary>
                    ///     A collection of serializable methods and their parameters/return types.
                    /// </summary>
                    public Dictionary<string, SerializableMethodRecord[]> SerializableMethods => _serializableMethods
                        .Concat(_coreData.SerializableMethods)
                        .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
                
                    private readonly Dictionary<string, SerializableMethodRecord[]> _serializableMethods = new()
                    {

                """);
        }
        else
        {
            outputBuilder = new(
                """
                    /// <summary>
                    ///     A collection of serializable methods and their parameters/return types.
                    /// </summary>
                    public Dictionary<string, SerializableMethodRecord[]> SerializableMethods => _serializableMethods;

                    private readonly Dictionary<string, SerializableMethodRecord[]> _serializableMethods = new()
                    {

                """);
        }

        foreach (var classGroup in serializedMethodsCollection.GroupBy(m => m.ClassName))
        {
            outputBuilder.AppendLine($$"""
                                               ["{{classGroup.Key}}"] = 
                                                   [
                                       """);

            foreach (var methodRecord in classGroup)
            {
                if (methodRecord.Parameters.Values.Contains("T")
                   || methodRecord.Parameters.Values.Contains("T?")
                   || methodRecord.ReturnType == "T"
                   || methodRecord.ReturnType == "T?"
                   || methodRecord.ReturnType == "T[]"
                   || methodRecord.ReturnType == "T[]?"
                   || methodRecord.ReturnType?.Contains("<T>") == true)
                {
                    continue;
                }
                outputBuilder.AppendLine($$"""
                                                           new SerializableMethodRecord("{{methodRecord.MethodName}}",
                                                               [
                                           """);

                foreach (var param in methodRecord.Parameters)
                {
                    bool isNullable = param.Value.EndsWith("?");
                    string value = isNullable ? param.Value.TrimEnd('?') : param.Value;
                    string isNullableText = isNullable ? "true" : "false";
                    string? collectionType = null;

                    if (value.EndsWith("[]"))
                    {
                        collectionType = value.Replace("[]", "");
                    }
                    else if (value.Contains("<") && value.Contains(">"))
                    {
                        int genericStart = value.IndexOf("<", StringComparison.OrdinalIgnoreCase);
                        collectionType = value.Substring(genericStart + 1, value.Length - genericStart - 2);
                    }
                    
                    string collectionText = collectionType is null
                        ? "null"
                        : $"typeof({collectionType})";
                    outputBuilder.AppendLine($"                        new SerializableParameterRecord(typeof({value}), {isNullableText}, {collectionText}),");
                }

                if (methodRecord.ReturnType != null)
                {
                    string returnValue = methodRecord.ReturnType.TrimEnd('?');

                    bool isCollectionReturn = returnValue.EndsWith("[]") ||
                                              (returnValue.Contains("<") && returnValue.Contains(">"));
                    
                    string protoKey = isCollectionReturn
                        ? returnValue.Contains("<") && returnValue.Contains(">")
                            ? returnValue.Substring(returnValue.IndexOf("<", StringComparison.OrdinalIgnoreCase) + 1,
                                returnValue.Length - returnValue.IndexOf("<", StringComparison.OrdinalIgnoreCase) - 2) + "Collection"
                            : returnValue.Replace("[]", "Collection")
                        : returnValue;
                    protoDefinitions.TryGetValue(protoKey, out ProtoMessageDefinition? protoDefinition);
                    string protoText = protoDefinition is not null
                        ? $"typeof({protoDefinition.Name}SerializationRecord)"
                        : "null";
                    outputBuilder.AppendLine($"                    ], new SerializableReturnRecord(false, {protoText})),");
                }
                else
                {
                    outputBuilder.AppendLine("                ])),");
                }
            }

            outputBuilder.AppendLine("       ],");
        }

        outputBuilder.AppendLine("    };");

        return outputBuilder.ToString();
    }
}

public record SerializableMethodRecord(string ClassName, string MethodName, Dictionary<string, string> Parameters,
    string ReturnType)
{
    public string ClassName { get; } = ClassName;
    public string MethodName { get; } = MethodName;
    public Dictionary<string, string> Parameters { get; } = Parameters;
    public string? ReturnType { get; } = ReturnType;
}